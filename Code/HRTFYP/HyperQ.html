<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>HyperQ</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/font-awesome.min.css">
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous" referrerpolicy="no-referrer">
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer">

    <style>
        
        html, body {
            height: 100%;
            overflow: hidden; 
            margin: 0;
            padding: 0;
        }

        
        .container-fluid {
            height: 100vh;
            padding: 10px 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        
        .top-buttons {
            flex-shrink: 0;
            margin-bottom: 10px;
        }

        
        .main-row {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        #pageloader {
            background: rgba(255, 255, 255, 0.8);
            display: none;
            position: fixed;
            margin-top: -32px;
            height: 100%;
            width: 100%;
            z-index: 9999;
        }

        #pageloader img {
            top: 50%;
            left: 50%;
            margin-left: -32px;
            margin-top: -132px;
            position: absolute;
        }

        .nav-bottom {
            position: relative;
        }

        .nav {
            display: flex;
            margin-bottom: 5px;
        }

        .nav > div {
            padding: 5px 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .nav > div.active {
            border-bottom: 2px solid #007bff;
            font-weight: bold;
            color: #007bff;
        }

        .nav > div:hover {
            background-color: #f8f9fa;
        }

        #board-tools {
            position: absolute;
            top: 2px;
            left: 2px;
            z-index: 2;
        }

        #board-help {
            position: absolute;
            top: 2px;
            right: 10px;
            z-index: 2;
        }

        #board-help button:hover,
        #step-count:hover,
        #mapping-count:hover,
        #pattern-count:hover {
            cursor: help;
        }

        
        #node-counter {
            position: absolute;
            top: 40px;
            right: 10px;
            z-index: 2;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            color: #495057;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        #node-counter .fa {
            margin-right: 5px;
            color: #007bff;
        }

        .card-header,
        .card-footer {
            padding-top: 0.375rem;
            padding-bottom: 0.375rem;
        }

        #labels-panel {
            width: 220px !important;  
            min-width: 220px;
            margin-top: 0;
            height: 100%;  
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #resize-gap {
            cursor: col-resize;
            width: 16px;
        }

        #resize-gap::after {
            
            content: "";
            display: block;
            transform: translate(-50%, -50%);
            margin-top: 380px;
            margin-left: 8px;
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: #ddd;
            box-shadow: 0 20px #ddd, 0 40px #ddd;
        }

        .collapse {
            display: none;
        }

        .collapse.show {
            display: block;
        }

        .list-group-item .fa {
            margin-right: 5px;
        }

        .list-group .list-group-item.inside-list-group-item:first-child {
            border-top: 1px solid rgba(0, 0, 0, .125);
        }

        .list-group .list-group-item.inside-list-group-item:last-child {
            margin-bottom: -1px;
        }

        
        .sigma-board-container {
            width: 100%;
            min-width: 500px;
            height: 600px;
            position: relative;
            margin-top: 40px;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            background: white;
        }

        #generated-patterns-panel {
            height: 280px;
            margin-top: 10px;
        }


        .sigma-generated-pattern-container {
            height: 100px;
            cursor: pointer;
            z-index: 1;
        }

        .tooltip-inner {
            max-width: 600px;
            text-align: left;
        }

        .scrolly {
            overflow-y: auto !important;
            height: 100%;
        }

        .sigma-query-pattern-container {
            cursor: pointer;
            user-select: none;
            margin-bottom: 4px;
        }

        a.list-group-item.active, a.list-group-item.active:hover {
            color: #FFF !important;
        }


        .match-container {
            width: 100%;                    
            height: auto;                   
            padding: 15px;
            margin: 20px auto;              
            border-bottom: 2px solid #eee;  
        }

        
        .match-container:last-child {
            border-bottom: none;
        }

        
        .match-title {
            font-size: 16px;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 3px solid #ddd;
        }

        #query-patterns-panel {
            width: 400px !important;        
            height: 100%;  
        }

        
        .sigma-scene {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }



        .match-container {
            width: 100%;
            padding: 15px;
            margin-bottom: 20px;
            border: 3px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .match-container:hover {
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .match-container.active {
            border-color: #007bff;
            box-shadow: 0 2px 5px rgba(0,123,255,0.3);
        }

        .match-title {
            font-size: 16px;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
        }





        .match-title {
            font-size: 16px;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }



        .match-container:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        #patterns-panel {
            position: absolute;
            right: 0;
            top: 50px;
        }

        
        #query-constructor {
            width: 68% !important;  
            margin-right: 2px;  
        }



        
        .match-container {
            width: 100%;
            min-height: 300px;  
        }


        
        #default-patterns-container {
            position: relative;
            top: auto;
            left: auto;
            width: 100%;
            background: white;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 5px;
            z-index: 1;
            overflow: hidden; 
            
        }
        
        
        #default-patterns-container .card-body {
            overflow-y: auto; 
            overflow-x: hidden; 
            max-height: calc(100% - 50px); 
        }

        #default-patterns-list {
            display: flex;
            flex-direction: column; 
            gap: 8px; 
            padding: 8px 4px 4px 4px; 
            height: fit-content;
            
            margin-top: 5px; 
        }

        #default-patterns-list:active {
            cursor: grabbing; 
        }

        .sigma-default-pattern-container {
            width: calc(100% - 8px); 
            max-width: 190px; 
            height: 130px; 
            margin: 2px; 
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: move;
            transition: all 0.2s ease;
            flex-shrink: 0; 
            padding: 6px; 
            box-sizing: border-box; 
        }

        .sigma-default-pattern-container:hover {
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        
        .ui-draggable-dragging {
            z-index: 1001;
        }




        
        .datastore-header {
            margin-bottom: 10px;
            z-index: 2;             
            position: relative;
        }


        
        .datastore-header {
            text-align: right;
            margin-bottom: 10px;
            z-index: 2;
            position: relative;
        }

        
        .main-content {
            display: flex;
            width: 100%;
        }


        
        .main-row {
            display: flex;
            width: 100%;
            margin-right: 0;
            margin-left: 0;
        }




        
        #board-tools {
            position: absolute;
            top: 2px;
            left: 2px;
            z-index: 2;
        }

        #board-help {
            position: absolute;
            top: 2px;
            right: 10px;
            z-index: 2;
        }

        
        .nav-pills {
            margin-bottom: 10px;
        }

        .row {
            display: flex;
            width: 100%;
            margin: 0;
        }

        
        #labels-panel {
            width: 220px !important;  
            min-width: 220px;
            flex-shrink: 0;
            padding-left: 15px;
            padding-right: 5px;  
            height: 100%; 
            max-height: 100%;
        }

        
        .middle-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            padding: 0 15px;
            max-width: calc(100% - 350px); 
            height: 100%;
            overflow: hidden;
        }



        
        #board-tools {
            position: absolute;
            top: 2px;
            left: 2px;
            z-index: 2;
        }

        #board-help {
            position: absolute;
            top: 2px;
            right: 10px;
            z-index: 2;
        }

        
        .nav-pills .active,
        .nav-pills div:first-child {
            background-color: #ffffff !important;  
            color: #007bff !important;             
            padding: 8px 20px;
            border-radius: 5px;
            font-weight: bold;
            border: 2px solid #007bff !important; 
        }

        
        .nav > div:first-child,
        #query-constructor-nav {
            background-color: #ffffff !important;  
            color: #007bff !important;             
            border: 2px solid #007bff !important;  
            padding: 8px 20px;
            border-radius: 5px;
            font-weight: bold;
        }

        
        .nav > div:first-child:hover,
        #query-constructor-nav:hover,
        .nav > div:first-child:focus,
        #query-constructor-nav:focus,
        .nav > div:first-child:active,
        #query-constructor-nav:active {
            background-color: #f8f9fa !important; 
            color: #0056b3 !important;             
            border: 2px solid #0056b3 !important;  
        }

        
        #resize-gap {
            width: 15px;  
            flex-shrink: 0;
        }

        
        .container-fluid {
            max-width: 100%;
            overflow: hidden; 
        }

        
        #query-patterns-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr); 
            gap: 10px; 
            padding: 10px;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            flex: 1; 
        }

        
        @media (min-width: 600px) {
            #query-patterns-list {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (min-width: 800px) {
            #query-patterns-list {
                grid-template-columns: repeat(2, 1fr); 
            }
        }

        .sigma-query-result-container:hover {
            border-color: #17a2b8;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }


        
        .match-container {
            width: 100%;
            height: auto;
            padding: 15px;
            margin: 0;
            border-bottom: 1px solid #eee;
        }

        
        .sigma-scene {
            position: absolute !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
        }




        
        #patterns-panel {
            width: 500px !important;              
            flex-shrink: 0;
            padding-right: 15px;
            margin-top: 50px;                     
            height: calc(100vh - 120px);          
            max-height: calc(100vh - 120px);      
        }

        #query-patterns-panel {
            width: 100% !important;
            height: 100%;                          
            margin-top: 0;
            display: flex;
            flex-direction: column;
        }

        
        #resize-gap {
            width: 15px;
            flex-shrink: 0;
        }

        .container-fluid {
            padding-right: 1px;
            padding-left: 25px;
            max-width: 100%;
        }




        
        .main-content {
            display: flex;
            height: 100%; 
            margin-top: 10px;
        }

        
        .card-header {
            padding: 10px 15px;
            margin-bottom: 0;
            background-color: #f8f9fa;
        }

        
        .card {
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .card-body {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        
        .sigma-query-result-board {
            width: 100% !important;
            height: 200px !important;
            margin: 0 auto;
            background: white;
            border: 2px solid #ccc;
            border-radius: 5px;
            position: relative;
            display: block;
            box-sizing: border-box;
        }

        
        #query-result {
            width: 100%;
            height: auto;
            margin: 20px 0;
        }

        .status-item {
            display: flex;
            align-items: center;
        }

        .status-item i {
            margin-right: 5px;
        }

        .status-item span {
            font-weight: bold;
        }

        .status-timer {
            color: #17a2b8;
        }

        .status-steps {
            color: #28a745;
        }

        .status-patterns {
            color: #ffc107;
        }
        
        
        .edge-legend {
            font-size: 11px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px;
        }
        
        .legend-line {
            display: inline-block;
            width: 20px;
            height: 3px;
            margin-right: 8px;
            border-radius: 1px;
        }
        
        
        .labels-column, .edge-types-column {
            padding: 8px; 
            height: 250px; 
            max-height: 250px;
        }
        
        .column-title {
            font-size: 12px; 
            font-weight: bold;
            margin-bottom: 8px; 
            color: #666;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px; 
        }
        
        .labels-list {
            height: calc(100% - 30px); 
            overflow-y: auto;
        }
        
        .edge-legend {
            height: calc(100% - 30px); 
            overflow-y: auto;
            padding-right: 5px;
            font-size: 14px; 
        }
        
        
        .col-6:first-child {
            border-right: 1px solid #dee2e6;
        }
        
        
        .card-body .row {
            margin: 0;
        }
        
        .card-body .col-6 {
            padding: 0;
        }

        .column-title {
            font-size: 11px; 
            font-weight: bold;
            margin-bottom: 6px; 
            color: #666;
            border-bottom: 1px solid #eee;
            padding-bottom: 2px; 
        }
        
        .labels-list {
            height: calc(100% - 25px); 
            overflow-y: auto;
        }
        
        .edge-legend {
            height: calc(100% - 25px); 
            overflow-y: auto;
            padding-right: 5px;
            font-size: 12px; 
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 3px; 
        }
        
        .legend-line {
            display: inline-block;
            width: 16px; 
            height: 2px; 
            margin-right: 6px; 
            border-radius: 1px;
        }
        
        
        .col-6:first-child {
            border-right: 1px solid #dee2e6;
        }
        
        
        .card-body .row {
            margin: 0;
        }
        
        .card-body .col-6 {
            padding: 0;
        }

        
        .modern-btn {
            display: inline-block !important;
            padding: 12px 24px;
            margin: 0 5px;
            border: none;
            border-radius: 8px;
            font-size: 16px !important;
            font-weight: 500;
            text-align: center;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
            overflow: visible; 
            white-space: nowrap; 
            vertical-align: middle; 
            line-height: normal; 
            min-width: 120px; 
            min-height: 45px; 
        }

        .modern-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .modern-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .modern-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
        }

        .modern-btn-primary:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6c5ce7 100%) !important;
            color: white !important;
        }

        .modern-btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%) !important;
            color: white !important;
        }

        .modern-btn-success:hover {
            background: linear-gradient(135deg, #43a047 0%, #66bb6a 100%) !important;
            color: white !important;
        }



        .modern-btn i {
            margin-right: 8px;
            font-size: 14px; 
            vertical-align: middle;
        }

        
        .modern-btn i.fa:before {
            content: "📄"; 
            font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
        }
        
        .modern-btn i.fa-file-text:before {
            content: "📄"; 
        }

        
        .modern-btn,
        .modern-btn:hover,
        .modern-btn:focus,
        .modern-btn:active {
            color: white !important;
            text-shadow: none !important;
            background-clip: padding-box !important;
        }

        
        .modern-btn i.fa::before {
            font-family: FontAwesome, "Apple Color Emoji", "Segoe UI Emoji", sans-serif !important;
        }
        
        
        .modern-btn {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important;
        }

        
        .draggable-label-node {
            transition: all 0.2s ease;
        }

        .draggable-label-node:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        .draggable-label-node.selected {
            background-color: #cce5ff !important;
            border-color: #007bff !important;
        }

        .draggable-label-node:active {
            cursor: grabbing !important;
        }

        
        #board.drag-over {
            border: 2px dashed #007bff !important;
            background-color: rgba(0, 123, 255, 0.05) !important;
        }

        #board.drag-over::before {
            content: "Drop here to add node";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 123, 255, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 1000;
            pointer-events: none;
        }

        
        .label-search-container {
            box-sizing: border-box;
        }

        .compact-search-group {
            max-width: 100%;
            overflow: hidden;
        }

        .compact-search-group > div {
            max-width: 100%;
            overflow: hidden;
        }

        #label-search-input {
            box-sizing: border-box;
        }

        #label-search-input:focus {
            box-shadow: none !important;
        }

        #clear-label-search:hover {
            background-color: rgba(108, 117, 125, 0.1) !important;
            border-radius: 2px;
        }

        
        .compact-search-group * {
            flex-shrink: 0;
        }

        .compact-search-group input {
            flex-shrink: 1 !important;
            min-width: 50px !important;
        }
    </style>
</head>

<body>
<div id="pageloader">
    <img src="img/Ripple-1s-200px.svg" alt="processing..."/>
</div>
<div class="container-fluid">
    
    <div class="top-buttons">
        <div class="row my-3">
            <div class="col-12 pl-3 pr-2">
                <button type="button" class="modern-btn modern-btn-primary" data-toggle="modal"
                        data-target="#load-local-patterns-modal">
                    <i class="fa fa-file-text"></i>
                    Load graph
                </button>
                <button type="button" class="modern-btn modern-btn-success" id="direct-query-btn">
                    <i class="fa fa-play"></i>
                    Query processing
                </button>
                
                
                <div class="query-params-inline" style="margin-left: 20px; display: inline-flex; align-items: center; gap: 15px;">
                    <div class="param-group">
                        <label for="inline-numberofpatterns" style="font-size: 12px; margin-right: 5px;">Patterns (1-50):</label>
                        <input type="number" id="inline-numberofpatterns" min="1" max="50" value="10" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                    </div>
                    <div class="param-group">
                        <label for="inline-minnode" style="font-size: 12px; margin-right: 5px;">Min Nodes (2-100):</label>
                        <input type="number" id="inline-minnode" min="2" max="100" value="8" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                    </div>
                    <div class="param-group">
                        <label for="inline-maxnode" style="font-size: 12px; margin-right: 5px;">Max Nodes (2-100):</label>
                        <input type="number" id="inline-maxnode" min="2" max="100" value="10" style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px;">
                    </div>
                </div>
                
                <div class="pull-right">
                    <div class="status-bar">
                        <button type="button" class="status-item status-timer" id="timer">
                            <i class="fa fa-play"></i>
                            <span>00:00</span>
                        </button>
                        <button type="button" class="status-item status-steps" id="step-count" data-toggle="tooltip" data-trigger="hover" data-placement="bottom" data-html="true">
                            <i class="fas fa-shoe-prints"></i>
                            <span>0</span>
                        </button>
                        <button type="button" class="status-item status-patterns" id="pattern-count" data-toggle="tooltip" data-trigger="hover" data-placement="bottom" data-html="true">
                            <i class="fas fa-chart-bar"></i>
                            <span>0</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    
    <div class="main-row">
        
        <div id="labels-panel">
            <div class="card" id="default-patterns-container" style="height: 60%; margin-bottom: 10px;">
                <div class="card-header p-2">
                    <h6 class="mb-0">Default patterns</h6>
                </div>
                <div class="card-body p-2">
                    <div id="default-patterns-list">
                        
                    </div>
                </div>
            </div>
            
            <div class="card" style="height: calc(40% - 10px); min-height: 300px;">
                <div class="card-header">
                    Labels & Edge Types
                </div>
                <div class="card-body p-0">
                    <div class="row" id="labels-edge-container">
                        
                        <div class="col-6" id="labels-column">
                            <div class="labels-column">
                                <h6 class="column-title">Labels Used</h6>
                                
                                <div class="label-search-container" style="padding: 3px 8px; border-bottom: 1px solid #e9ecef;">
                                    <div class="compact-search-group" style="display: flex; align-items: center; width: 100%;">
                                        <div style="display: flex; align-items: center; background: #f8f9fa; border: 1px solid #ced4da; border-radius: 3px; flex: 1; min-width: 0;">
                                            <span style="padding: 3px 6px; border-right: 1px solid #ced4da; display: flex; align-items: center;">
                                                <i class="fa fa-search" style="color: #6c757d; font-size: 11px;"></i>
                                            </span>
                                            <input type="text" id="label-search-input" 
                                                   placeholder="Search..." 
                                                   style="border: none; outline: none; background: transparent; padding: 3px 6px; font-size: 11px; flex: 1; min-width: 0; width: 100%;">
                                            <button type="button" id="clear-label-search" 
                                                    style="border: none; background: transparent; color: #6c757d; padding: 2px 4px; cursor: pointer; display: flex; align-items: center;">
                                                <i class="fa fa-times" style="font-size: 10px;"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div class="list-group list-group-flush scrolly labels-list">
                                    <div id="nested-labels"></div>
                                    <div id="plain-labels"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-6" id="edge-types-column">
                            <div class="edge-types-column">
                                <h6 class="column-title">Edge Types</h6>
                                <div class="edge-legend">
                                    <div class="legend-item">
                                        <span class="legend-line" style="background-color: #7B68EE;"></span>
                                        <span>Single Bond (default)</span>
                                    </div>
                                    <div class="legend-item">
                                        <span class="legend-line" style="background-color: #FF1493;"></span>
                                        <span>Aromatic Bond (Alt)</span>
                                    </div>
                                    <div class="legend-item">
                                        <span class="legend-line" style="background-color: #FF4500;"></span>
                                        <span>Double Bond (Shift)</span>
                                    </div>
                                    <div class="legend-item">
                                        <span class="legend-line" style="background-color: #32CD32;"></span>
                                        <span>Triple Bond (Ctrl)</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="resize-gap"></div>

        
        <div class="middle-section">
            <div class="nav nav-pills">
                <div id="query-constructor-nav" class="active" style="font-weight: 500; cursor: pointer;">Query constructor</div>
            </div>
            <div id="query-constructor" class="nav-bottom">
                <div id="board-tools">
                    <div class="btn-group" role="group">
                        
                        <button type="button" id="new-window-btn" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="New window">
                            <i class="fa fa-file-o"></i>
                        </button>
                        
                        <button type="button" id="check-status-btn" class="btn btn-info" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Check search mode">
                            <i class="fa fa-question"></i>
                        </button>
                        
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Expand"
                                onclick="scaleNodes(s, 0 == s.activeState.nbNodes() ? s.graph.nodes() : s.activeState.nodes(), 1.2);">
                            <i class="fa fa-expand"></i>
                        </button>
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Shrink"
                                onclick="scaleNodes(s, 0 == s.activeState.nbNodes() ? s.graph.nodes() : s.activeState.nodes(), 0.8);">
                            <i class="fa fa-compress"></i>
                        </button>
                        
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Rotate clockwise"
                                onclick="if (1 != s.activeState.nbNodes()) rotateNodes(s, 0 == s.activeState.nbNodes() ? s.graph.nodes() : s.activeState.nodes(), Math.PI / 4);">
                            <i class="fa fa-rotate-right"></i>
                        </button>
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Rotate anticlockwise"
                                onclick="if (1 != s.activeState.nbNodes()) rotateNodes(s, 0 == s.activeState.nbNodes() ? s.graph.nodes() : s.activeState.nodes(), -Math.PI / 4);">
                            <i class="fa fa-rotate-left"></i>
                        </button>
                        
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Select with lasso"
                                onclick="if (s.lasso.isActive) s.lasso.deactivate(); else s.lasso.activate();">
                            <i class="fa fa-lastfm"></i>
                        </button>
                        
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Detach label"
                                onclick="detachLabel(s, s.activeState.nodes());">
                            <i class="fa fa-eraser"></i>
                        </button>
                        
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Save Query"
                                onclick="saveQueryGraph();">
                            <i class="fa fa-save"></i>
                        </button>
                        
                        <button type="button" id="undo-query-btn" class="btn btn-warning" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="Undo to pre-query state" disabled>
                            <i class="fa fa-undo"></i>
                        </button>
                        
                        <button type="button" id="optimize-layout-btn" class="btn btn-success" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" title="🌟 完全自由布局优化 - 所有节点平等参与，获得最佳显示效果" style="display: none;">
                            <i class="fa fa-magic"></i>
                        </button>
                    </div>
                </div>
                <div id="board-help">
                    <div class="btn-group" role="group">
                        
                        <button type="button" class="btn btn-light" data-toggle="tooltip" data-trigger="hover"
                                data-placement="bottom" data-html="true"
                                title="<strong><u>Add node</u></strong><br>click background (double click when some nodes are selected)<br><strong><u>Add edge types</u></strong><br>click source node and target node successively<br>• No key: Single bond (purple)<br>• Shift: Double bond (orange)<br>• Ctrl: Triple bond (green)<br>• Alt: Aromatic bond (pink)<br><strong><u>Attach/Change label</u></strong><br>select node and double click the specific label<br><strong><u>Move node(s)/edge(s)</u></strong><br>drag node with left mouse button<br><strong><u>Add pattern</u></strong><br>drag pattern to the board<br><strong><u>Remove node(s)</u></strong><br>right click node<br><strong><u>Remove edge</u></strong><br>right click edge<br><strong><u>Select node(s)</u></strong><br>click node or select with lasso<br><strong><u>Clear select status</u></strong><br>click background<br>">
                            <i class="fa fa-question-circle"></i>
                        </button>
                    </div>
                </div>
                
                <div id="node-counter" data-toggle="tooltip" data-trigger="hover" data-placement="left" title="Number of nodes in constructor">
                    <i class="fa fa-circle"></i>
                    <span id="node-count">0</span> nodes
                </div>
                <div id="board" class="sigma-board-container"></div>
            </div>
            <div id="query-result" style="display: none">
                <div id="board-res"></div>
            </div>
        </div>

        
        <div id="patterns-panel">
            <div class="card modern-panel" id="query-patterns-panel">
                <div class="modern-panel-header">
                    <span>Query result</span>
                    <div class="modern-stats" style="display: none;">
                        <i class="fa fa-clock-o"></i>
                        <span id="result-timer">--:--</span>
                        <i class="fa fa-tasks"></i>
                        Steps <span id="result-step-count">-</span>
                        <i class="fa fa-cube"></i>
                        Used patterns <span id="result-pattern-count">-</span>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div id="query-patterns-list" class="scrolly">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="load-datastore-catapult-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">Upload datastore</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="upload-file">Graph file</label>
                            <div class="custom-file">
                                <input type="file" class="custom-file-input form-control" id="upload-file-catapult"
                                       name="file" required>
                                <label class="custom-file-label" for="upload-file">Choose file...</label>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>


    <div class="modal fade" id="upload-datastore-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">Upload datastore</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="upload-datastore-name">Name</label>
                            <input type="text" id="upload-datastore-name" name="name" class="form-control" required>
                        </div>
                        <div class="form-group">
                            <label for="upload-file">Graph file</label>
                            <div class="custom-file">
                                <input type="file" class="custom-file-input form-control" id="upload-file" name="file"
                                       required>
                                <label class="custom-file-label" for="upload-file">Choose file...</label>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="load-datastore-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">Load datastore</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="load-datastore-name">Available datastores</label>
                            <select class="custom-select form-control" id="load-datastore-name" required>
                            </select>
                        </div>
                        <hr>
                        <div class="form-group">
                            <label for="datastore-pending-list">Pending list</label>
                            <ul id="datastore-pending-list">
                            </ul>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="generate-patterns-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">
                            Generate patterns
                            <br>
                            <small class="text-muted">
                                Note that this process may take some time.
                            </small>
                        </h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="generate-patterns-num">K Selection</label>
                            <input type="number" min="1" value="3" class="form-control" id="generate-patterns-num"
                                   required>
                        </div>
                        
                        
                    
                        
                        
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="load-local-patterns-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">Load graph</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="database-select">Select Database</label>
                            <select class="form-control" id="database-select" required>
                                <option value="1">AIDS10K</option>
                                <option value="2">emolecul</option>
                                <option value="3">pubchem23238</option>
                            </select>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="customized-hub-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">Add customized ego</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="customized-hub-degree">Specify degree of ego</label>
                            <input type="number" min="3" max="20" value="6" class="form-control"
                                   id="customized-hub-degree" required>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <div class="modal fade" id="customized-ring-modal" tabindex="-1" role="dialog">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <form>
                    <div class="modal-header">
                        <h5 class="modal-title">Add customized ring</h5>
                        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="customized-ring-length">Specify length of ring</label>
                            <input type="number" min="3" max="20" value="6" class="form-control"
                                   id="customized-ring-length" required>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-primary">OK</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>


<div class="modal fade" id="query-params-modal" tabindex="-1" role="dialog">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <form id="query-params-form">
                <div class="modal-header">
                    <h5 class="modal-title">Query Parameters</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="param-numberofpatterns">numberofpatterns (1-50)</label>
                        <input type="number" class="form-control" id="param-numberofpatterns" 
                               min="1" max="50" value="10" required>
                    </div>
                    <div class="form-group">
                        <label for="param-minnode">Minimum Nodes (2-100)</label>
                        <input type="number" class="form-control" id="param-minnode" 
                               min="2" max="100" value="2" required>
                    </div>
                    <div class="form-group">
                        <label for="param-maxnode">Maximum Nodes (2-100)</label>
                        <input type="number" class="form-control" id="param-maxnode" 
                               min="2" max="100" value="10" required>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="submit" class="btn btn-primary">Start Processing</button>
                </div>
            </form>
        </div>
    </div>
</div>


<script src="js/jquery-3.3.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>

<script>
    'use strict';
    let NODE_SIZE = 17;
    let NODE_COLOR1 = '#A9A9A9'; 
    let NODE_COLOR2 = '#E6E6FA';
    let NODE_COLOR3 = '#E6E6FA';
    let NODE_COLOR_OTHER = '#E6E6FA';
    let EDGE_SIZE = 8;
    let EDGE_COLOR = '#7B68EE';
    let LABEL_COLOR = 'fbe9e7';
    let LABEL_SIZE = 17;
    let MIN_NODE_DISTANCE = 32;
    let NODE_HALO_SIZE = 10;
    let NODE_HALO_COLOR = 'rgba(236, 81, 72, 0.2)';
    
   
    const EDGE_TYPE_COLORS = {
        0: '#7B68EE',   
        1: '#FF4500',   
        2: '#32CD32',   
        3: '#FF1493',   
        4: '#FFD700',   
        5: '#20B2AA'    
    };
    
    
    function getEdgeColor(edgeType) {
        return EDGE_TYPE_COLORS[edgeType] || EDGE_COLOR;
    }
    
    let PATTERN_NODE_SIZE = 8; 
    let PATTERN_EDGE_SIZE = 3;
    let RESULT_NODE_SIZE = 10;
    let RESULT_EDGE_SIZE = 3;
    let PATTERN_LABEL_SIZE = 17;
    let LAYOUT_RUN_TIME = 800; 
    let PATTERN_LAYOUT_TIME = 500; 
    let RESULT_LAYOUT_TIME = 1000; 

    let boardSigmaSettings = {
        defaultNodeColor: '#A9A9A9',
        defaultEdgeColor: EDGE_COLOR,
        edgeColor: 'default',
        defaultLabelColor: LABEL_COLOR,
        defaultLabelSize: LABEL_SIZE,
        fontStyle: 'bold',
        labelAlignment: 'center',
        labelThreshold: 0,
        enableEdgeHovering: true,
        autoRescale: false,
        mouseWheelEnabled: false,
        doubleClickEnabled: false,
        nodeActiveBorderSize: 2,
        nodeActiveOuterBorderSize: 3,
        defaultNodeActiveBorderColor: '#fff',
        defaultNodeActiveOuterBorderColor: 'rgb(236, 81, 72)',
        nodeHaloColor: NODE_HALO_COLOR,
        nodeHaloSize: NODE_HALO_SIZE,
       
        minNodeSize: 8,
        maxNodeSize: 8,
        borderSize: 2,
        nodeBorderColor: 'default',
        defaultNodeBorderColor: '#666',
        nodeColor: 'default',
        defaultNodeColor: '#A9A9A9',
        drawNodes: true,
        drawEdges: true,
        drawLabels: true
    };
    let boardResSigmaSettings = {
        defaultNodeColor: '#A9A9A9',
        defaultEdgeColor: EDGE_COLOR,
        edgeColor: 'default',
        defaultLabelColor: LABEL_COLOR,
        defaultLabelSize: LABEL_SIZE,
        fontStyle: 'bold',
        labelAlignment: 'center',
        labelThreshold: 0,
        enableEdgeHovering: true,
        autoRescale: true,
        mouseWheelEnabled: true,
        doubleClickEnabled: false,
        nodeActiveBorderSize: 2,
        nodeActiveOuterBorderSize: 3,
        defaultNodeActiveBorderColor: '#fff',
        defaultNodeActiveOuterBorderColor: 'rgb(236, 81, 72)',
        nodeHaloColor: NODE_HALO_COLOR,
        nodeHaloSize: NODE_HALO_SIZE
    };
    let patternSigmaSettings = {
        defaultNodeColor: NODE_COLOR1,
        defaultEdgeColor: EDGE_COLOR,
        defaultLabelColor: '#000000', 
        defaultLabelSize: 16, 
        fontStyle: 'bold',
        labelAlignment: 'center',
        labelThreshold: 0, 
        edgeColor: 'default',
        autoRescale: false,
        touchEnabled: false,
        mouseEnabled: false,
        mouseWheelEnabled: false,
        doubleClickEnabled: false,
        enableHovering: false,
        eventsEnabled: false,
        minNodeSize: 10, 
        maxNodeSize: 10, 
        borderSize: 2,
        nodeBorderColor: 'default',
        defaultNodeBorderColor: '#000',
        nodeColor: 'default',
        drawNodes: true,
        drawEdges: true,
        drawLabels: true,
        labelSize: 'fixed' 
    };

    let FORCE_ATLAS2_SETTINGS = {
        barnesHutOptimize: true,   
        strongGravityMode: true,   
        gravity: 2,                
        scalingRatio: 10,         
        slowDown: 2                
    };
    let highlightedNodes = []
    let highlightedEdges = []

   
    let currentSelectedLabel = null; 
    let currentSelectedLabelId = null; 

    
    function getCurrentQueryGraphNodeCount() {
        try {
           
            if (s && s.graph && s.graph.nodes) {
                const nodeCount = s.graph.nodes().length;
                console.log(`Current query graph has ${nodeCount} nodes`);
                return nodeCount;
            }
            return 0;
        } catch (error) {
            console.error('Error getting query graph node count:', error);
            return 0;
        }
    }

    
    function setQueryParametersDefaults() {
        const currentNodeCount = getCurrentQueryGraphNodeCount();
        
       
        const databaseConfig = {
            'AIDS': { minIncrease: 3, maxIncrease: 4 },
            'emolecule': { minIncrease: 2, maxIncrease: 4 },
            'pubchem': { minIncrease: 2, maxIncrease: 4 },
            'default': { minIncrease: 2, maxIncrease: 3 } 
        };
        
       
        const config = databaseConfig[currentDataset] || databaseConfig['default'];
        
        if (currentNodeCount > 0) {
            const minNodes = Math.max(2, currentNodeCount + config.minIncrease); 
            const maxNodes = Math.max(2, currentNodeCount + config.maxIncrease); 
            
           
            const clampedMinNodes = Math.min(minNodes, 100);
            const clampedMaxNodes = Math.min(maxNodes, 100);
            
            $('#param-minnode').val(clampedMinNodes);
            $('#param-maxnode').val(clampedMaxNodes);
            
            console.log(`Set query parameters for ${currentDataset}: current=${currentNodeCount}, min=${clampedMinNodes} (+${config.minIncrease}), max=${clampedMaxNodes} (+${config.maxIncrease})`);
        } else {
           
            $('#param-minnode').val(2);
            $('#param-maxnode').val(10);
            console.log(`No nodes found, using default values for ${currentDataset}: min=2, max=10`);
        }
    }

   
    const ATOMIC_ELEMENT_COLORS = {
        'C': '#2E8B57',   
        'N': '#4169E1',   
        'O': '#DC143C',   
        'H': '#F0F8FF',   
        'S': '#FFD700',   
        'P': '#FF4500',   
        'F': '#00FF7F',   
        'Cl': '#32CD32',  
        'Br': '#8B4513',  
        'I': '#800080',   
        'Na': '#FFB6C1',  
        'Si': '#808080',  
        'Cu': '#CD853F',  
        'Zn': '#708090',  
        'B': '#DDA0DD',   
        'Co': '#FF69B4',  
        'Mn': '#9370DB',  
        'As': '#2F4F4F',  
        'Al': '#D3D3D3',  
        'Ni': '#98FB98',  
        'Se': '#FA8072',  
        'V': '#FF1493',   
        'Sn': '#B0C4DE',  
        'Fe': '#CD5C5C',  
        'Pd': '#DEB887',  
        'Hg': '#C0C0C0',  
        'Bi': '#DA70D6',  
        'Ca': '#FFE4E1',  
        'Ti': '#87CEEB',  
        'Ge': '#FFA07A',  
        'Pt': '#F5DEB3',  
        'Ru': '#FFFFE0',  
        'Rh': '#E0FFFF',  
        'Cr': '#F0FFFF',  
        'Ga': '#FFE4B5',  
        'K': '#FFEFD5',   
        'Ag': '#F8F8FF',  
        'Au': '#FAFAD2',  
        'Ir': '#FFF8DC',  
        'Te': '#FFFACD',  
        'Mg': '#F5F5DC',  
        'Pb': '#696969',  
        'W': '#778899',   
        'Cs': '#DCDCDC',  
        'Mo': '#A9A9A9',  
        'Re': '#BC8F8F',  
        'Cd': '#F5F5F5',  
        'Os': '#FDF5E6',  
        'Li': '#FF6347',  
        'Sb': '#40E0D0',  
       
        'default': '#A9A9A9' 
    };

    
    function getNodeColorByLabel(label) {
       
        if (ATOMIC_ELEMENT_COLORS[label]) {
            return ATOMIC_ELEMENT_COLORS[label];
        }
        
       
        const reverseMapping = getCurrentReverseAtomicLabels();
        const atomicSymbol = reverseMapping[String(label)];
        
        if (atomicSymbol && ATOMIC_ELEMENT_COLORS[atomicSymbol]) {
            return ATOMIC_ELEMENT_COLORS[atomicSymbol];
        }
        
       
        return ATOMIC_ELEMENT_COLORS['default'];
    }

    let defaultPatterns = [
        {
            type: 'default',
            title: 'Single node',
            nodes: [{id: 0, label: 1}],
            edges: []
        },
        {
            type: 'default', 
            title: 'Edge',
            nodes: [{id: 0, label: 1}, {id: 1, label: 1}],
            edges: [{source: 0, target: 1, type: 0}]
        },
        {
            type: 'default',
            title: 'Triangle',
            nodes: [{id: 0, label: 1}, {id: 1, label: 1}, {id: 2, label: 1}],
            edges: [{source: 0, target: 1, type: 0}, {source: 1, target: 2, type: 0}, {source: 2, target: 0, type: 0}]
        },
        {
            type: 'hub',
            title: 'Customized ego',
            degree: 4
        },
        {
            type: 'ring',
            title: 'Customized ring', 
            length: 6
        }
    ];

    let s;
    let sd;
    let mouseMoved = false;
    let beforeDragNodeId = undefined;
    let draggingNodes = {};
    let dragDx, dragDy;
    let lastTimeClickOnBoard = new Date();

    let datastoreName;

    let queryPatternSigmaObjects = [];

    let generatedPatternsTab = $('#generated-patterns-tab');
    let generatedPatternsContent = $('#generated-patterns-tab-content');
    let generatedPatternSigmaObjects = [];
    let generatedPatternSigmaObjectsByTab = {};

    let customizedHubRadius, customizedRingRadius;
    let addPatternCenter;

    let displayPatterns = [];

    let queryResults = [];

   
    let fixedLabels = {
        'elements': {}
    };

    let timerEnabled = false;
    let timer;
    let queryStats = [];
    let usedRecommendedPattern = false;
    let isCopyingRecommendedPattern = false;

    function Counter(type) {
        this.counter = {};
        this.type = type;
        this.detailedLog = [];
        
        this.display = function () {
            console.log(`Counter.display() called for type: ${this.type}`);
            console.log(`Counter data:`, this.counter);
            
            let msg = '<strong><u>Details</u></strong><br>';
            let cnt = 0;
            for (let t in this.counter) {
                msg += `<b>${t}: </b>${this.counter[t]}<br>`;
                cnt += this.counter[t];
            }
            if (0 == cnt)
                msg += 'None<br>';
            $(`#${this.type}-count`).attr('data-original-title', msg);
            
           
            let displayText = cnt == Math.round(cnt) ? cnt : cnt.toFixed(2);
            console.log(`Setting display text for #${this.type}-count span: "${displayText}"`);
            
            const targetElement = $(`#${this.type}-count span`);
            console.log(`Target element found:`, targetElement.length > 0, targetElement);
            
            targetElement.text(displayText);
            
            console.log(`Display updated. Current text:`, targetElement.text());
        }
        
        this.inc = function (name, details = '') {
            const timestamp = new Date().getTime();
            console.log(`Counter.inc() called for type: ${this.type}, name: "${name}", details: "${details}"`);
            console.log(`Counter before increment:`, this.counter);
            
           
            this.detailedLog.push({
                action: name,
                details: details,
                timestamp: timestamp,
                time: new Date().toLocaleTimeString()
            });
            
            if (this.counter[name]) {
                this.counter[name]++;
            } else {
                this.counter[name] = 1;
            }
            
            console.log(`Counter after increment:`, this.counter);
            console.log(`Operation logged: ${name} - ${details}`);
            this.display();
        }
        
        this.append = function (num) {
            this.counter[Object.keys(this.counter).length + 1] = num;
            this.display();
        }
        
        this.reset = function () {
            this.counter = {};
            this.detailedLog = [];
            this.display();
        }
        
       
        this.getDetailedReport = function() {
            return {
                summary: this.counter,
                log: this.detailedLog,
                total: Object.values(this.counter).reduce((a, b) => a + b, 0)
            };
        }
        
        this.display();
    }

    let stepCounter = new Counter('step');
    let patternCounter = new Counter('pattern');
    let mappingTimeCounter = new Counter('mapping');

    
    function reset(s) {
        s.camera.goTo({x: 0, y: 0});
        s.nodeCnt = 0;
        s.edgeCnt = 0;
        s.graph.clear();
        s.refresh();
        debouncedSaveQueryGraph();

        stepCounter.reset();
        patternCounter.reset();
        lastTimeClickOnBoard = new Date();
        mappingTimeCounter.reset();
        
       
        if (s === window.sigma_constructor) {
            updateNodeCounter();
        }
    }

    
    function loadDefaultPatterns() {
        $.ajax({
            url: '/get_default_patterns',
            method: 'GET',
            success: function(response) {
                if (response.success) {
                    console.log('Loaded default patterns for database:', response.database);
                    console.log('Patterns:', response.patterns);
                    
                   
                    defaultPatterns = response.patterns;
                    
                   
                    generateDefaultPatternsPanel();
                } else {
                    console.error('Failed to load default patterns:', response.message);
                   
                    generateDefaultPatternsPanel();
                }
            },
            error: function(xhr, status, error) {
                console.error('Error loading default patterns:', error);
               
                generateDefaultPatternsPanel();
            }
        });
    }

    
    function addNode(s, x, y, ignoreMerge, label) {
       
        if (true != ignoreMerge) {
            let neighbor = s.graph.nodes().find(function (n) {
                return Math.sqrt(Math.pow(n.x - x, 2) + Math.pow(n.y - y, 2)) < s.minNodeDistance;
            });
            if (undefined != neighbor) {
                console.error('[addNode] too close to node ' + neighbor.id);
                return false;
            }
        }
        if (undefined == label)
            label = '';
        let id = s.nodeCnt++;
        
       
        const nodeColor = getNodeColorByLabel(label);
        
        s.graph.addNode({
            id: id,
            size: s.nodeSize,
            x: x,
            y: y,
            label: label,
            active: false,
            hidden: false,
            color: nodeColor, 
            borderColor: '#666',
            borderSize: 2     
        });
        s.refresh();
                debouncedSaveQueryGraph();
        
       
        debouncedUpdateSnapshot();
        
       
        if (s === window.sigma_constructor) {
            updateNodeCounter();
        }
        
        return true;
    }

    function addNodeById(s, x, y, ignoreMerge, label, id) {
        console.log("addnode:", x, y, ignoreMerge, label, id)
        if (true != ignoreMerge) {
            let neighbor = s.graph.nodes().find(function (n) {
                return Math.sqrt(Math.pow(n.x - x, 2) + Math.pow(n.y - y, 2)) < s.minNodeDistance;
            });
            if (undefined != neighbor) {
                console.error('[addNode] too close to node ' + neighbor.id);
                return false;
            }
        }
        if (undefined == label)
            label = '';
            
       
        const nodeColor = getNodeColorByLabel(label);
        
        s.graph.addNode({
            id: id,
            size: s.nodeSize,
            x: x,
            y: y,
            label: label,
            active: false,
            hidden: false,
            color: nodeColor, 
            borderColor: '#666',
            borderSize: 2     
        });
        console.log("ADDOK")
        s.refresh();
                debouncedSaveQueryGraph();
        
       
        debouncedUpdateSnapshot();
        
       
        if (s === window.sigma_constructor) {
            updateNodeCounter();
        }
        
        return true;
    }

    
    function findEdge(s, x, y) {
       
        const [minId, maxId] = x < y ? [x, y] : [y, x];
        return s.graph.edges().find(function (e) {
            return e.source === minId && e.target === maxId;
        });
    }

    
    function addEdge(s, x, y, edgeType) {
        let nodeX = s.graph.nodes().find(function (n) {
            return n.id == x;
        });
        if (undefined == nodeX) {
            console.error('[addEdge] not found node ' + x);
            return false;
        }
        let nodeY = s.graph.nodes().find(function (n) {
            return n.id == y;
        });
        if (undefined == nodeY) {
            console.error('[addEdge] not found node ' + y);
            return false;
        }
        if (nodeX == nodeY) {
            console.error('[addEdge] same source and target');
            return false;
        }
        if (undefined != findEdge(s, x, y)) {
            console.error('[addEdge] edge already exists');
            return false;
        }
        let id = s.edgeCnt++;
        
       
        const [source, target] = x < y ? [x, y] : [y, x];
        
       
       
       
        const type = edgeType || 0;
        
        s.graph.addEdge({
            id: id,
            source: source,
            target: target,
            size: s.edgeSize,
            type: type,
           
            color: getEdgeColor(type),
            hidden: false
        });
        s.refresh();
                debouncedSaveQueryGraph();
        
       
        debouncedUpdateSnapshot();
        
        return true;
    }

    
    function inActiveState(s, x) {
        return undefined != s.activeState.nodes().find(n => n.id == x);
    }

    
    function mergeNodes(s) {
        let handled,
            nodeDropList,
            edgeAddList,
            nodeMap,
            nodes = s.graph.nodes(),
            num = nodes.length;

       
        for (let i = 0; i < num; ++i)
            for (let j = i + 1; j < num; ++j)
                if (Math.sqrt(Math.pow(nodes[i].x - nodes[j].x, 2) + Math.pow(nodes[i].y - nodes[j].y, 2)) < s.minNodeDistance)
                    if (nodes[i].label != '' && nodes[j].label != '' && nodes[i].label != nodes[j].label) {
                        alert(`Unable to merge nodes with different labels ('${nodes[i].label}' and '${nodes[j].label}')!`);
                        s.graph.nodes().forEach(n => {
                            if (n.id in draggingNodes)
                                [n.x, n.y] = draggingNodes[n.id];
                        });
                        s.refresh();
                debouncedSaveQueryGraph();
                        return;
                    }

        while (true) {
            handled = new Set();
            nodeDropList = new Set();
            edgeAddList = [];
            nodeMap = {};
            nodes = s.graph.nodes();
            num = nodes.length;
            nodes.forEach(n => nodeMap[n.id] = n.id);
            for (let i = 0; i < num; ++i)
                if (!handled.has(nodes[i].id)) {
                    let minI = -1, minD = 1e20;
                    for (let j = i + 1; j < num; ++j)
                        if (!handled.has(nodes[j].id)) {
                            let d = Math.sqrt(Math.pow(nodes[i].x - nodes[j].x, 2) + Math.pow(nodes[i].y - nodes[j].y, 2));
                            if (d < minD) {
                                minI = j;
                                minD = d;
                            }
                        }
                    if (minD < s.minNodeDistance) {
                        let a = i, b = minI;
                        if (inActiveState(s, nodes[b].id))
                            [a, b] = [b, a];
                        s.graph.edges().forEach(e => {
                            if (e.source == nodes[b].id)
                                edgeAddList.push(nodes[a].id, e.target);
                            else if (e.target == nodes[b].id)
                                edgeAddList.push(e.source, nodes[a].id);
                        });
                        handled.add(nodes[i].id).add(nodes[minI].id);
                        if ('' == nodes[a].label)
                            nodes[a].label = nodes[b].label;
                        nodeDropList.add(nodes[b].id);
                        nodeMap[nodes[b].id] = nodes[a].id;
                    }
                }
            if (nodeDropList.size) {
                console.log('drop nodes', nodeDropList);
                nodeDropList.forEach(x => s.graph.dropNode(x));
                for (let i = 0; i < edgeAddList.length; i += 2)
                    addEdge(s, nodeMap[edgeAddList[i]], nodeMap[edgeAddList[i + 1]]);
            } else
                break;
        }
        s.refresh();
                debouncedSaveQueryGraph();
        
       
        debouncedUpdateSnapshot();
        
       
        if (s === window.sigma_constructor) {
            updateNodeCounter();
        }
    }

    
    function rotateNodes(s, nodes, angle, ignoreMerge) {
        let num = nodes.length;
        if (1 == num)
            return;
        let minX = 1e20, maxX = -1e20, minY = 1e20, maxY = -1e20;
        nodes.forEach(n => {
            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x);
            minY = Math.min(minY, n.y);
            maxY = Math.max(maxY, n.y);
        });
        let oX = (minX + maxX) / 2, oY = (minY + maxY) / 2;
        nodes.forEach(n => {
            let x = n.x - oX, y = n.y - oY;
            n.x = x * Math.cos(angle) - y * Math.sin(angle) + oX;
            n.y = x * Math.sin(angle) + y * Math.cos(angle) + oY;
        });
        s.refresh();
                debouncedSaveQueryGraph();
        if (true != ignoreMerge)
            mergeNodes(s);
        lastTimeClickOnBoard = new Date();
    }

    
    function scaleNodes(s, nodes, ratio, ignoreMerge) {
        let num = nodes.length;
        if (1 == num || 1.0 == ratio)
            return;
        let sumX = 0.0, sumY = 0.0;
        nodes.forEach(n => {
            sumX += n.x;
            sumY += n.y;
        });
        let oX = sumX / num, oY = sumY / num;
        nodes.forEach(n => {
            n.x = (n.x - oX) * ratio + oX;
            n.y = (n.y - oY) * ratio + oY;
        });
        s.refresh();
                debouncedSaveQueryGraph();
        if (true != ignoreMerge)
            mergeNodes(s);
        lastTimeClickOnBoard = new Date();
    }

    
    function detachLabel(s, nodes) {
        nodes.forEach(n => {
            n.label = '';
           
            n.color = ATOMIC_ELEMENT_COLORS['default'];
        });
        s.activeState.dropNodes();
        s.refresh();
                debouncedSaveQueryGraph();
        
       
        debouncedUpdateSnapshot();
        
        lastTimeClickOnBoard = new Date();
       
        stepCounter.inc('修改标签', `移除${nodes.length}个节点的标签`);
    }

    
    function attachLabel(s, nodes, label) {
        if (nodes && nodes.length > 0) {
            const elementSymbol = getCurrentReverseAtomicLabels()[String(label)] || String(label);
            nodes.forEach(node => {
               
                node.originalLabel = String(label);
               
                node.label = elementSymbol;
                
               
                node.color = getNodeColorByLabel(node.label);
            });
            s.activeState.dropNodes();
            s.refresh();
            lastTimeClickOnBoard = new Date();
           
            stepCounter.inc('修改标签', `为${nodes.length}个节点设置标签"${elementSymbol}"`);
        }
    }

    
    function changeLayout(s, opt) {
        switch (opt) {
            case 'dagre':
                sigma.layouts.dagre.configure(s, {
                    rankdir: 'TB'
                });
                sigma.layouts.dagre.start(s);
                break;
            case 'forceAtlas2':
                s.startForceAtlas2({});
                setTimeout(function () {
                    s.stopForceAtlas2();
                }, 5000);
                break;
            case 'fruchtermanReingold':
                sigma.layouts.fruchtermanReingold.start(s, {});
                break;
            case 'noverlap':
               
                s.configNoverlap({
                    nodeMargin: 18,   
                    scaleNodes: 1.2,  
                    speed: 3,         
                    maxIterations: 100
                });
                s.startNoverlap();
                break;
            case 'forceLink':
                sigma.layouts.startForceLink(s);
                setTimeout(function () {
                    sigma.layouts.stopForceLink();
                }, 5000);
                break;
            case 'layout1':
                s.startForceAtlas2(FORCE_ATLAS2_SETTINGS);
                setTimeout(function () {
                    s.stopForceAtlas2();
                   
                    s.configNoverlap({
                        nodeMargin: 18,   
                        scaleNodes: 1.2,  
                        speed: 3,         
                        maxIterations: 100
                    });
                    s.startNoverlap();
                }, 5000);
                break;
            case 'layout2':
                sigma.layouts.startForceLink(s);
                setTimeout(function () {
                    sigma.layouts.stopForceLink();
                   
                    s.configNoverlap({
                        nodeMargin: 18,   
                        scaleNodes: 1.2,  
                        speed: 3,         
                        maxIterations: 100
                    });
                    s.startNoverlap();
                }, 5000);
                break;
        }
    }

    function resetHighlightNodesAndEdges() {
        highlightedNodes.forEach(nodeId => {
            const node = sd.graph.nodes(nodeId);
            if (node) {
                node.color = NODE_COLOR1
            }
        })
        highlightedEdges.forEach(edgeId => {
            const edge = sd.graph.edges(edgeId);
            if (edge) {
               
                edge.color = getEdgeColor(edge.type || 0)
            }
        })
        highlightedNodes = []
        highlightedEdges = []
        sd.refresh()
    }

    function resetQueryResultPanel() {
        $("#query-patterns-list").text("Waiting for processing...")
    }

    
    async function verifyTEDResults() {
        console.log("Starting automatic TED verification and filtering process...");
        
        try {
           
            const response = await $.ajax({
                url: '/verify_ted',
                method: 'POST',
                timeout: 90000 
            });
            
            if (response.success) {
                console.log("TED verification and filtering successful:", response);
                
               
                const analysis = response.verificationSummary || '';
                
               
                if (response.needsReplacement && response.replacementGraphs) {
                    console.log("TED verification found issues, replacement needed, number of replacements:", response.replacementGraphs.length);
                    
                   
                    const verifiedResults = response.replacementGraphs.map((graph, index) => {
                        return {
                            nodes: graph.nodes.map(node => ({
                                id: node.id,
                                label: node.label
                            })),
                            edges: graph.edges.map(edge => ({
                                source: edge.source,
                                target: edge.target,
                                type: edge.type || 0
                            }))
                        };
                    });
                    
                    console.log("Transformed replacement results:", verifiedResults);
                    return {
                        needsReplacement: true,
                        replacementGraphs: verifiedResults,
                        verificationSummary: analysis,
                        verificationPassed: false
                    };
                } else {
                   
                    console.log("TED verification and filtering completed, using filtered TED results");
                    
                   
                    const wasFiltered = analysis.includes('filtered') || analysis.includes('retained') || analysis.includes('removed');
                    const isSuccess = analysis.includes('✅') || response.verificationPassed;
                    
                    return {
                        needsReplacement: false,
                        verificationSummary: analysis,
                        verificationPassed: isSuccess,
                        wasFiltered: wasFiltered
                    };
                }
            } else {
                console.warn("TED verification failed:", response.error || "Unknown error");
                return {
                    needsReplacement: false,
                    verificationSummary: `TED verification failed: ${response.error || "Unknown error"}`,
                    verificationPassed: false
                };
            }
        } catch (error) {
            console.error("Error during TED verification:", error);
            
            let errorMessage = "Error during TED verification";
            
           
            if (error.statusText === 'timeout') {
                errorMessage = "TED verification timeout, possibly due to complex graph or large database";
                console.warn("TED verification timeout, using original query results");
            } else if (error.status === 500) {
                errorMessage = "Internal server error during TED verification";
            } else if (error.status === 0) {
                errorMessage = "Unable to connect to TED verification service";
            }
            
            return {
                needsReplacement: false,
                verificationSummary: `${errorMessage}, using original query results`,
                verificationPassed: false
            };
        }
    }

    
    function showTEDVerificationMessage(message) {
       
        console.log("TED verification message:", message);
        
       
        let notificationType = 'info';
        let backgroundColor = '#d1ecf1';
        let borderColor = '#bee5eb';
        let textColor = '#0c5460';
        
        if (message.includes('❌')) {
            notificationType = 'error';
            backgroundColor = '#f8d7da';
            borderColor = '#f5c6cb';
            textColor = '#721c24';
        } else if (message.includes('⚠️')) {
            notificationType = 'warning';
            backgroundColor = '#fff3cd';
            borderColor = '#ffeaa7';
            textColor = '#856404';
        } else if (message.includes('✅')) {
            notificationType = 'success';
            backgroundColor = '#d4edda';
            borderColor = '#c3e6cb';
            textColor = '#155724';
        }
        
       
        let title = 'TED Verification Tip';
        if (message.includes('filtered')) {
            title = 'TED Graph Filtering Verification';
        }
        
       
        if (message.includes('❌') || message.includes('⚠️') || message.includes('filtered')) {
            const notification = $('<div>')
                .addClass('ted-verification-notification')
                .css({
                    'position': 'fixed',
                    'top': '80px',
                    'right': '20px',
                    'background': backgroundColor,
                    'border': `1px solid ${borderColor}`,
                    'border-radius': '8px',
                    'padding': '15px',
                    'max-width': '350px',
                    'z-index': '9999',
                    'box-shadow': '0 4px 12px rgba(0,0,0,0.15)',
                    'color': textColor,
                    'font-size': '14px',
                    'line-height': '1.4'
                })
                .html(`
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <strong>${title}</strong>
                        <span style="cursor: pointer; opacity: 0.7; font-size: 16px;">&times;</span>
                    </div>
                    <div>${message.replace(/\n/g, '<br/>')}</div>
                `);
            
            $('body').append(notification);
            
           
            const duration = message.includes('filtered') ? 8000 : 5000;
            
           
            setTimeout(() => {
                notification.fadeOut(500, () => {
                    notification.remove();
                });
            }, duration);
            
           
            notification.find('span').click((e) => {
                e.stopPropagation();
                notification.fadeOut(300, () => {
                    notification.remove();
                });
            });
            
            notification.click(() => {
                notification.fadeOut(300, () => {
                    notification.remove();
                });
            });
        }
    }

    
    function rotateTofitContainer(s) {
        if (s.graph.nodes().length <= 1)
            return;
        let maxI = -1;
        let maxR = -1e20;
       
        let w = s.renderers[0].container.offsetWidth && s.renderers[0].container.offsetWidth > 0 ? s.renderers[0].container.offsetWidth : s.containerDefaultWeight;
        let h = s.renderers[0].container.offsetHeight && s.renderers[0].container.offsetHeight > 0 ? s.renderers[0].container.offsetHeight : s.containerDefaultHeight;
        for (let i = 0; i < 18; ++i) {
            let nodes = s.graph.nodes();
            let num = nodes.length;
            let minX = 1e20, maxX = -1e20, minY = 1e20, maxY = -1e20;
            nodes.forEach(n => {
                minX = Math.min(minX, n.x);
                maxX = Math.max(maxX, n.x);
                minY = Math.min(minY, n.y);
                maxY = Math.max(maxY, n.y);
            });
            let r = Math.min(w / (maxX - minX), h / (maxY - minY));
            if (r > maxR) {
                maxI = i;
                maxR = r;
            }
            rotateNodes(s, nodes, Math.PI / 18, true);
        }
        rotateNodes(s, s.graph.nodes(), Math.PI / 18 * (18 + maxI), true);
    }

    
    function scaleTofitContainer(s) {
        let nodes = s.graph.nodes();
        let num = nodes.length;
        if (1 == num) {
            let p = s.camera.cameraPosition(0, 0);
            nodes[0].x = p.x;
            nodes[0].y = p.y;
            s.refresh();
                debouncedSaveQueryGraph();
            return;
        }
       
        let w = s.renderers[0].container.offsetWidth && s.renderers[0].container.offsetWidth > 0 ? s.renderers[0].container.offsetWidth : s.containerDefaultWeight;
        let h = s.renderers[0].container.offsetHeight && s.renderers[0].container.offsetHeight > 0 ? s.renderers[0].container.offsetHeight : s.containerDefaultHeight;
        let minX = 1e20, maxX = -1e20, minY = 1e20, maxY = -1e20;
        nodes.forEach(n => {
            minX = Math.min(minX, n.x);
            maxX = Math.max(maxX, n.x);
            minY = Math.min(minY, n.y);
            maxY = Math.max(maxY, n.y);
        });
        let oX = (minX + maxX) / 2, oY = (minY + maxY) / 2;
        
       
        let baseFactor = 0.75;
        
       
        if (s.nodeSize === RESULT_NODE_SIZE) {
            if (num >= 20) {
                baseFactor = 0.80;
                console.log(`Conservative scale factor for large result graph (${num} nodes): ${baseFactor}`);
            } else if (num >= 15) {
                baseFactor = 0.78;
                console.log(`Conservative scale factor for medium result graph (${num} nodes): ${baseFactor}`);
            } else if (num > 10) {
                baseFactor = 0.75; 
                console.log(`Conservative scale factor for small result graph (${num} nodes): ${baseFactor}`);
            } else {
                baseFactor = 0.73;
                console.log(`Default scale factor for very small result graph (${num} nodes): ${baseFactor}`);
            }
        } else {
           
            baseFactor = 0.7;
        }
        
        let r = Math.min(w / (maxX - minX), h / (maxY - minY)) * baseFactor;
        nodes.forEach(n => {
            n.x = (n.x - oX) * r;
            n.y = (n.y - oY) * r;
        });
        s.camera.goTo({x: 0, y: 0});
        s.refresh();
                debouncedSaveQueryGraph();
    }

    
    function drawDefaultPattern(s, pattern) {
        switch (pattern.type) {
            case 'default':
               
                if (pattern.nodes && pattern.edges) {
                   
                    let gap = PATTERN_NODE_SIZE * 3;
                    
                    pattern.nodes.forEach((node, i) => {
                        const atomicLabel = getCurrentReverseAtomicLabels()[node.label.toString()] || node.label.toString();
                        addNodeById(s, 
                            Math.random() * gap * 2 - gap, 
                            i * gap * 0.5,                 
                            true,                          
                            atomicLabel,                   
                            node.id                        
                        );
                    });
                    
                   
                    pattern.edges.forEach(edge => {
                        addEdge(s, edge.source, edge.target, edge.type);
                    });
                    
                   
                    if (pattern.nodes.length <= 3) {
                        setTimeout(() => {
                            scaleTofitContainer(s);
                            s.refresh();
                debouncedSaveQueryGraph();
                        }, 50); 
                    } else {
                       
                        s.startForceAtlas2();
                        setTimeout(() => {
                            s.stopForceAtlas2();
                           
                            s.configNoverlap({
                                nodeMargin: 20,   
                                scaleNodes: 1.3,  
                                speed: 3,         
                                maxIterations: 100
                            });
                            s.startNoverlap();
                            setTimeout(() => {
                                scaleTofitContainer(s);
                                s.refresh();
                debouncedSaveQueryGraph();
                            }, PATTERN_LAYOUT_TIME); 
                        }, PATTERN_LAYOUT_TIME); 
                    }
                } else if (pattern.n && pattern.e) {
                   
                    let gap = PATTERN_NODE_SIZE * 3;
                    pattern.n.forEach((n, i) => {
                        addNode(s, 
                            Math.random() * gap * 2 - gap, 
                            i * gap * 0.5, 
                            true, 
                            n[1], 
                            n[0]
                        );
                    });
                    
                    pattern.e.forEach(pair => addEdge(s, pair[0], pair[1], 1));
                    
                   
                    s.startForceAtlas2();
                    setTimeout(() => {
                        s.stopForceAtlas2();
                       
                        s.configNoverlap({
                            nodeMargin: 20,   
                            scaleNodes: 1.3,  
                            speed: 3,         
                            maxIterations: 100
                        });
                        s.startNoverlap();
                        setTimeout(() => {
                            scaleTofitContainer(s);
                            s.refresh();
                debouncedSaveQueryGraph();
                        }, PATTERN_LAYOUT_TIME); 
                    }, PATTERN_LAYOUT_TIME); 
                }
                break;
            
            case 'hub':
                drawCustomizedHub(s, 0, 0, pattern.degree, true);
                break;
            
            case 'ring':
                drawCustomizedRing(s, 0, 0, pattern.length, true);
                break;
            
            case 'generated':
                drawGeneratedPattern(s, pattern);
                break;
        }
    }
    
    
    function isChainStructure(pattern) {
        if (!pattern.nodes || !pattern.edges || pattern.nodes.length < 2) {
            return false;
        }
        
       
        const nodeDegrees = {};
        pattern.nodes.forEach(node => {
            nodeDegrees[node.id] = 0;
        });
        
        pattern.edges.forEach(edge => {
            nodeDegrees[edge.source]++;
            nodeDegrees[edge.target]++;
        });
        
       
        let endPoints = 0;
        let middlePoints = 0;
        
        Object.values(nodeDegrees).forEach(degree => {
            if (degree === 1) endPoints++;
            else if (degree === 2) middlePoints++;
            else return false;
        });
        
       
        return endPoints === 2 && (endPoints + middlePoints) === pattern.nodes.length;
    }
    
    
    function drawChainWithFolding(s, pattern) {
       
        pattern.nodes.forEach(node => {
            const atomicLabel = getCurrentReverseAtomicLabels()[node.label.toString()] || node.label.toString();
            addNodeById(s, 0, 0, true, atomicLabel, node.id);
        });
        
       
        pattern.edges.forEach(edge => {
            addEdge(s, edge.source, edge.target, edge.type);
        });
        
       
        const nodeDegrees = {};
        pattern.nodes.forEach(node => {
            nodeDegrees[node.id] = 0;
        });
        
        pattern.edges.forEach(edge => {
            nodeDegrees[edge.source]++;
            nodeDegrees[edge.target]++;
        });
        
        const startNode = pattern.nodes.find(node => nodeDegrees[node.id] === 1);
        if (!startNode) return;
        
       
        const adjacency = {};
        pattern.nodes.forEach(node => {
            adjacency[node.id] = [];
        });
        pattern.edges.forEach(edge => {
            adjacency[edge.source].push(edge.target);
            adjacency[edge.target].push(edge.source);
        });
        
       
        const visited = new Set();
        const positions = [];
        let current = startNode.id;
        
        while (current !== undefined) {
            visited.add(current);
            positions.push(current);
            
           
            let next = undefined;
            for (const neighbor of adjacency[current]) {
                if (!visited.has(neighbor)) {
                    next = neighbor;
                    break;
                }
            }
            current = next;
        }
        
       
        const containerWidth = 140; 
        const containerHeight = 90; 
        const nodeSpacing = 25;     
        const nodesPerRow = Math.floor(containerWidth / nodeSpacing);
        
        positions.forEach((nodeId, index) => {
            const row = Math.floor(index / nodesPerRow);
            const col = index % nodesPerRow;
            
           
            const actualCol = (row % 2 === 0) ? col : (nodesPerRow - 1 - col);
            
            const x = (actualCol - (nodesPerRow - 1) / 2) * nodeSpacing;
            const y = (row - 1) * nodeSpacing;
            
           
            const node = s.graph.nodes().find(n => n.id === nodeId);
            if (node) {
                node.x = x;
                node.y = y;
            }
        });
        
       
        setTimeout(() => {
            scaleTofitContainer(s);
            s.refresh();
                debouncedSaveQueryGraph();
        }, 50);
    }

    
    function drawGeneratedPattern(s, pattern) {
        console.log(s, pattern)
        let gap = PATTERN_NODE_SIZE * 5;
        if (undefined != pattern.labels) {
            for (let i = 0; i < pattern.n; ++i)
                addNode(s, Math.random() * gap * 2 - gap, i * gap, true, pattern.labels[i]);
        } else {
            for (let i = 0; i < pattern.n; ++i)
                addNode(s, Math.random() * gap * 2 - gap, i * gap, true);
        }
        pattern.e.forEach(pair => addEdge(s, pair[0], pair[1], 0));
       
        s.startForceAtlas2({});
        setTimeout(() => {
           
           
            s.stopForceAtlas2(FORCE_ATLAS2_SETTINGS);
           
            s.configNoverlap({
                nodeMargin: 18,   
                scaleNodes: 1.2,  
                speed: 3,         
                maxIterations: 100
            });
            s.startNoverlap();
            setTimeout(() => {
                rotateTofitContainer(s);
                scaleTofitContainer(s);
                console.log("OVER")
            }, LAYOUT_RUN_TIME);
        }, LAYOUT_RUN_TIME);
    }

   
    let currentQuerySnapshot = { nodes: new Set(), edges: new Set() };
    let lastGraphHash = '';

   
    function saveCurrentQuerySnapshot() {
        const graph = s.graph;
        const nodes = graph.nodes();
        const edges = graph.edges();
        
       
        if (nodes.length === 0) {
            console.log('Clearing query snapshot: No nodes in current graph');
            currentQuerySnapshot.nodes = {};
            currentQuerySnapshot.edges = new Set();
            return;
        }
        
       
        const graphData = {
            nodes: nodes.map(n => ({id: n.id, label: n.label, x: n.x, y: n.y})),
            edges: edges.map(e => ({source: e.source, target: e.target, type: e.type || 0}))
        };
        const currentGraphHash = JSON.stringify(graphData);
        
       
        if (currentGraphHash === lastGraphHash) {
            return;
        }
        
       
        currentQuerySnapshot.nodes = {};
        currentQuerySnapshot.edges = new Set();
        
       
        nodes.forEach(node => {
            currentQuerySnapshot.nodes[node.id] = {
                id: node.id,
                label: node.label,
                x: node.x,
                y: node.y,
                size: node.size
            };
        });
        
       
        edges.forEach(edge => {
            const edgeKey1 = `${edge.source}-${edge.target}`;
            const edgeKey2 = `${edge.target}-${edge.source}`;
            currentQuerySnapshot.edges.add(edgeKey1);
            currentQuerySnapshot.edges.add(edgeKey2);
        });
        
        lastGraphHash = currentGraphHash;
        
        console.log('Updating query snapshot (with position info):', {
            nodeCount: Object.keys(currentQuerySnapshot.nodes).length,
            edgeCount: currentQuerySnapshot.edges.size,
            nodePositions: Object.fromEntries(Object.entries(currentQuerySnapshot.nodes).map(([id, node]) => [id, `(${node.x.toFixed(1)}, ${node.y.toFixed(1)})`]))
        });
    }

   
    let snapshotUpdateTimeout = null;
    function debouncedUpdateSnapshot() {
        if (snapshotUpdateTimeout) {
            clearTimeout(snapshotUpdateTimeout);
        }
        snapshotUpdateTimeout = setTimeout(() => {
            saveCurrentQuerySnapshot();
        }, 200);
    }

   
    function getOriginalQueryNodes() {
        return { 
            nodes: currentQuerySnapshot.nodes, 
            edges: currentQuerySnapshot.edges 
        };
    }

   
    function drawQueryHighlight(s) {
       
        const newNodes = s.graph.nodes().filter(node => node.isNewNode);
        
        console.log(`Found ${newNodes.length} new nodes to highlight`);
        
       
        const container = s.renderers[0].container;
        const existingSvg = container.querySelector('.query-highlight-svg');
        if (existingSvg) {
            existingSvg.remove();
        }
        
       
        container.querySelectorAll('.query-node-indicator, .new-node-indicator').forEach(el => el.remove());
        
        if (newNodes.length === 0) {
            console.log('No new nodes to mark (only contains query graph nodes)');
            return;
        }
        
       
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.classList.add('query-highlight-svg');
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '1000';
        container.appendChild(svg);
        
       
        newNodes.forEach(node => {
            const {nodeX, nodeY} = getScreenCoordinates(s, node, container);
            
           
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', nodeX);
            circle.setAttribute('cy', nodeY);
            circle.setAttribute('r', (node.size || 5) + 10);
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', '#ff6b6b');       
            circle.setAttribute('stroke-width', '2.5');     
            circle.setAttribute('stroke-dasharray', '8,4'); 
            circle.setAttribute('opacity', '0.9');          
            svg.appendChild(circle);
            
            console.log(`Drew new node highlight for ${node.id} at (${nodeX}, ${nodeY})`);
        });
        
        console.log(`Highlighting completed: Marked ${newNodes.length} new nodes`);
        
       
        const updateHighlight = () => drawQueryHighlight(s);
        s.bind('rescale', updateHighlight);
        s.bind('coordinatesUpdated', updateHighlight);
        
       
        s._queryHighlightCleanup = () => {
            s.unbind('rescale', updateHighlight);
            s.unbind('coordinatesUpdated', updateHighlight);
        };
    }
    
    
    function getScreenCoordinates(s, node, container) {
        const containerRect = container.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        
        const camera = s.camera;
        const nodeX = (node.x - camera.x) / camera.ratio + containerWidth / 2;
        const nodeY = (node.y - camera.y) / camera.ratio + containerHeight / 2;
        
        return {nodeX, nodeY};
    }
    


    
    function applySmartLayout(s, duration = 1000) {
        console.log('Starting enhanced smart layout algorithm...');
        
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        
       
        const queryNodes = nodes.filter(node => node.isOriginalQuery);
        const newNodes = nodes.filter(node => node.isNewNode);
        const allNodes = nodes;
        
        console.log(`Query nodes: ${queryNodes.length}, New nodes: ${newNodes.length}, Total nodes: ${allNodes.length}`);
        
        if (allNodes.length === 0) {
            console.log('No nodes to layout');
            s.refresh();
            return;
        }
        
       
        const totalNodes = nodes.length;
        const currentNodeSize = s.nodeSize || RESULT_NODE_SIZE;
        let baseDistance, repulsionStrength, attractionStrength;
        
       
        const distanceMultiplier = totalNodes > 20 ? 2.8 : totalNodes > 15 ? 3.0 : totalNodes > 12 ? 3.2 : 3.5;
        baseDistance = Math.max(30, currentNodeSize * distanceMultiplier);
        
        if (totalNodes > 20) {
            repulsionStrength = 1500;
            attractionStrength = 0.08;
            console.log(`Large graph layout parameters (balanced): Node=${currentNodeSize}, Distance=${baseDistance.toFixed(1)}, Repulsion=${repulsionStrength}`);
        } else if (totalNodes > 15) {
            repulsionStrength = 1300;
            attractionStrength = 0.10;
            console.log(`Medium-large graph layout parameters (balanced): Node=${currentNodeSize}, Distance=${baseDistance.toFixed(1)}, Repulsion=${repulsionStrength}`);
        } else if (totalNodes > 12) {
            repulsionStrength = 1100;
            attractionStrength = 0.12;
            console.log(`Medium graph layout parameters (balanced): Node=${currentNodeSize}, Distance=${baseDistance.toFixed(1)}, Repulsion=${repulsionStrength}`);
        } else {
            repulsionStrength = 900;
            attractionStrength = 0.15;
            console.log(`Small graph layout parameters (balanced): Node=${currentNodeSize}, Distance=${baseDistance.toFixed(1)}, Repulsion=${repulsionStrength}`);
        }
        
       
        const adjacencyMap = new Map();
        edges.forEach(edge => {
            if (!adjacencyMap.has(edge.source)) adjacencyMap.set(edge.source, []);
            if (!adjacencyMap.has(edge.target)) adjacencyMap.set(edge.target, []);
            adjacencyMap.get(edge.source).push(edge.target);
            adjacencyMap.get(edge.target).push(edge.source);
        });
        
       
        const layoutParams = {
            k: baseDistance,             
            repulsion: repulsionStrength,
            attraction: attractionStrength,
            damping: 0.85,              
            maxDisplacement: 8,         
            minDistance: baseDistance * 0.8, 
            maxEdgeLength: baseDistance * 2.2 
        };
        
       
       
        if (newNodes.length > 0) {
            console.log(`Setting intelligent initial positions for ${newNodes.length} new nodes...`);
            
            newNodes.forEach((node, i) => {
               
                const connectedQueryNodes = [];
                const neighbors = adjacencyMap.get(node.id) || [];
                
                neighbors.forEach(neighborId => {
                    const neighborNode = queryNodes.find(n => n.id === neighborId);
                    if (neighborNode) {
                        connectedQueryNodes.push(neighborNode);
                    }
                });
                
                if (connectedQueryNodes.length > 0) {
                   
                    const avgX = connectedQueryNodes.reduce((sum, n) => sum + n.x, 0) / connectedQueryNodes.length;
                    const avgY = connectedQueryNodes.reduce((sum, n) => sum + n.y, 0) / connectedQueryNodes.length;
                    
                   
                    const angle = Math.random() * 2 * Math.PI;
                    const radius = baseDistance * 1.2 + Math.random() * baseDistance * 0.8;
                    node.x = avgX + Math.cos(angle) * radius;
                    node.y = avgY + Math.sin(angle) * radius;
                    
                    console.log(`Node ${node.id} placed near connected query graph nodes (${connectedQueryNodes.length} connections)`);
                } else {
                   
                    const centerX = queryNodes.length > 0 ? 
                        queryNodes.reduce((sum, n) => sum + n.x, 0) / queryNodes.length : 0;
                    const centerY = queryNodes.length > 0 ? 
                        queryNodes.reduce((sum, n) => sum + n.y, 0) / queryNodes.length : 0;
                    
                    const angle = (i * 2 * Math.PI) / newNodes.length;
                    const radius = baseDistance * 1.5 + Math.random() * baseDistance * 0.5;
                    node.x = centerX + Math.cos(angle) * radius;
                    node.y = centerY + Math.sin(angle) * radius;
                    
                    console.log(`Node ${node.id} placed outside query graph (no direct connections)`);
                }
            });
            
            console.log(`Completed intelligent initial positioning for new nodes`);
        }
        
       
        const iterations = Math.floor(duration / 40);
        let currentIteration = 0;
        
       
        const originalPositions = new Map();
        let originalCentroid = { x: 0, y: 0 };
        
       
        if (queryNodes.length > 0) {
            originalCentroid.x = queryNodes.reduce((sum, node) => sum + node.x, 0) / queryNodes.length;
            originalCentroid.y = queryNodes.reduce((sum, node) => sum + node.y, 0) / queryNodes.length;
        }
        
       
        queryNodes.forEach(node => {
            const relativeX = node.x - originalCentroid.x;
            const relativeY = node.y - originalCentroid.y;
            const distance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);
            const angle = Math.atan2(relativeY, relativeX);
            
            originalPositions.set(node.id, { 
                x: node.x, 
                y: node.y,
                relativeX: relativeX,
                relativeY: relativeY,
                distance: distance,
                angle: angle
            });
        });
        
        const layoutInterval = setInterval(() => {
           
            allNodes.forEach(node => {
                let fx = 0, fy = 0;
                
               
                nodes.forEach(otherNode => {
                    if (node.id === otherNode.id) return;
                    
                    const dx = node.x - otherNode.x;
                    const dy = node.y - otherNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                       
                        const effectiveDistance = Math.max(distance, layoutParams.minDistance * 0.3);
                        let repulsionForce = layoutParams.repulsion / (effectiveDistance * effectiveDistance);
                        
                       
                        if (distance < layoutParams.minDistance) {
                            repulsionForce *= 3;
                        }
                        
                        fx += (dx / distance) * repulsionForce;
                        fy += (dy / distance) * repulsionForce;
                    }
                });
                
               
                const neighbors = adjacencyMap.get(node.id) || [];
                neighbors.forEach(neighborId => {
                    const neighbor = nodes.find(n => n.id === neighborId);
                    if (!neighbor) return;
                    
                    const dx = neighbor.x - node.x;
                    const dy = neighbor.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        let displacement = distance - layoutParams.k;
                        
                       
                        if (distance > layoutParams.maxEdgeLength) {
                            displacement = distance - layoutParams.k;
                           
                            const extraAttraction = (distance - layoutParams.maxEdgeLength) * 0.8;
                            displacement += extraAttraction;
                        } else if (distance > layoutParams.k * 1.5) {
                           
                            const moderateAttraction = (distance - layoutParams.k * 1.5) * 0.4;
                            displacement += moderateAttraction;
                        }
                        
                        const attractionForce = layoutParams.attraction * displacement;
                        fx += (dx / distance) * attractionForce;
                        fy += (dy / distance) * attractionForce;
                    }
                });
                
               
                const crossingForce = calculateEdgeCrossingForce(node, nodes, edges, layoutParams.k * 0.3);
                fx += crossingForce.x * 0.8;
                fy += crossingForce.y * 0.8;
                
               
                const spacingForce = calculateEdgeSpacingForce(node, nodes, edges, layoutParams.k * 0.4);
                fx += spacingForce.x * 0.6;
                fy += spacingForce.y * 0.6;
                
               
               
               
               
               
                
               
                fx *= layoutParams.damping;
                fy *= layoutParams.damping;
                
                const displacement = Math.sqrt(fx * fx + fy * fy);
                if (displacement > layoutParams.maxDisplacement) {
                    fx = (fx / displacement) * layoutParams.maxDisplacement;
                    fy = (fy / displacement) * layoutParams.maxDisplacement;
                }
                
               
                const movementScale = 1.0;
                node.x += fx * movementScale;
                node.y += fy * movementScale;
            });
            
           
            enforceMinimumDistance(nodes, layoutParams.minDistance);
            
           
            s.refresh();
            
            currentIteration++;
            if (currentIteration >= iterations) {
                clearInterval(layoutInterval);
                console.log('Smart layout completed');
                
               
                const crossingStats = analyzeEdgeCrossings(s);
                console.log(`Edge crossing analysis: ${crossingStats.crossings} crossing points, crossing rate: ${crossingStats.crossingRate.toFixed(2)}%`);
                
               
                const spacingStats = analyzeEdgeSpacing(s);
                console.log(`Line spacing analysis: ${spacingStats.tooClose} pairs of lines too close, average distance: ${spacingStats.averageDistance.toFixed(1)}px`);
                
               
                performFinalOverlapResolution(s);
                
               
                if (crossingStats.crossings > 0 || spacingStats.tooClose > 0) {
                    console.log('Performing final edge crossing and spacing optimization...');
                    performFinalCrossingOptimization(s, crossingStats.crossings);
                    
                    if (spacingStats.tooClose > 0) {
                        console.log('Performing line spacing optimization...');
                        performFinalSpacingOptimization(s, spacingStats.tooClose);
                    }
                }
            }
        }, 40);
    }
    
    
    function calculateEdgeCrossingForce(node, allNodes, allEdges, forceStrength) {
        let fx = 0, fy = 0;
        
       
        const nodeEdges = allEdges.filter(edge => 
            edge.source === node.id || edge.target === node.id
        );
        
        if (nodeEdges.length === 0) return {x: 0, y: 0};
        
       
        nodeEdges.forEach(nodeEdge => {
            const nodeEdgeStart = allNodes.find(n => n.id === nodeEdge.source);
            const nodeEdgeEnd = allNodes.find(n => n.id === nodeEdge.target);
            
            if (!nodeEdgeStart || !nodeEdgeEnd) return;
            
           
            allEdges.forEach(otherEdge => {
               
                if (nodeEdge.source === otherEdge.source || 
                    nodeEdge.source === otherEdge.target || 
                    nodeEdge.target === otherEdge.source || 
                    nodeEdge.target === otherEdge.target) {
                    return;
                }
                
                const otherEdgeStart = allNodes.find(n => n.id === otherEdge.source);
                const otherEdgeEnd = allNodes.find(n => n.id === otherEdge.target);
                
                if (!otherEdgeStart || !otherEdgeEnd) return;
                
               
                const intersection = getLineIntersection(
                    nodeEdgeStart.x, nodeEdgeStart.y, nodeEdgeEnd.x, nodeEdgeEnd.y,
                    otherEdgeStart.x, otherEdgeStart.y, otherEdgeEnd.x, otherEdgeEnd.y
                );
                
                if (intersection.intersects) {
                   
                    const repelForce = calculateRepelForceFromCrossing(
                        node, nodeEdgeStart, nodeEdgeEnd, otherEdgeStart, otherEdgeEnd, 
                        intersection, forceStrength
                    );
                    
                    fx += repelForce.x;
                    fy += repelForce.y;
                }
            });
        });
        
        return {x: fx, y: fy};
    }
    
    
    function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        
        if (Math.abs(denom) < 1e-10) {
            return {intersects: false};
        }
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
            const intersectionX = x1 + t * (x2 - x1);
            const intersectionY = y1 + t * (y2 - y1);
            return {
                intersects: true,
                x: intersectionX,
                y: intersectionY,
                t: t,
                u: u
            };
        }
        
        return {intersects: false};
    }
    
    
    function calculateRepelForceFromCrossing(node, edgeStart, edgeEnd, otherEdgeStart, otherEdgeEnd, intersection, forceStrength) {
        let fx = 0, fy = 0;
        
       
        const toIntersectionX = intersection.x - node.x;
        const toIntersectionY = intersection.y - node.y;
        const distanceToIntersection = Math.sqrt(toIntersectionX * toIntersectionX + toIntersectionY * toIntersectionY);
        
        if (distanceToIntersection > 0) {
           
            const repelStrength = forceStrength / Math.max(distanceToIntersection, 1);
            fx -= (toIntersectionX / distanceToIntersection) * repelStrength;
            fy -= (toIntersectionY / distanceToIntersection) * repelStrength;
        }
        
       
       
        const edgeVecX = edgeEnd.x - edgeStart.x;
        const edgeVecY = edgeEnd.y - edgeStart.y;
        
       
        const otherEdgeVecX = otherEdgeEnd.x - otherEdgeStart.x;
        const otherEdgeVecY = otherEdgeEnd.y - otherEdgeStart.y;
        
       
        const dotProduct = edgeVecX * otherEdgeVecX + edgeVecY * otherEdgeVecY;
        const crossProduct = edgeVecX * otherEdgeVecY - edgeVecY * otherEdgeVecX;
        
       
        if (Math.abs(crossProduct) < Math.abs(dotProduct) * 0.5) {
            const perpX = -edgeVecY;
            const perpY = edgeVecX;
            const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
            
            if (perpLength > 0) {
                const rotationForce = forceStrength * 0.3;
                fx += (perpX / perpLength) * rotationForce * Math.sign(crossProduct);
                fy += (perpY / perpLength) * rotationForce * Math.sign(crossProduct);
            }
        }
        
        return {x: fx, y: fy};
    }
    
    
    function calculateEdgeSpacingForce(node, allNodes, allEdges, forceStrength) {
        let fx = 0, fy = 0;
        
       
        const nodeEdges = allEdges.filter(edge => 
            edge.source === node.id || edge.target === node.id
        );
        
        if (nodeEdges.length === 0) return {x: 0, y: 0};
        
        const minLineDistance = 15;
        
       
        nodeEdges.forEach(nodeEdge => {
            const nodeEdgeStart = allNodes.find(n => n.id === nodeEdge.source);
            const nodeEdgeEnd = allNodes.find(n => n.id === nodeEdge.target);
            
            if (!nodeEdgeStart || !nodeEdgeEnd) return;
            
           
            allEdges.forEach(otherEdge => {
               
                if (nodeEdge.source === otherEdge.source || 
                    nodeEdge.source === otherEdge.target || 
                    nodeEdge.target === otherEdge.source || 
                    nodeEdge.target === otherEdge.target) {
                    return;
                }
                
                const otherEdgeStart = allNodes.find(n => n.id === otherEdge.source);
                const otherEdgeEnd = allNodes.find(n => n.id === otherEdge.target);
                
                if (!otherEdgeStart || !otherEdgeEnd) return;
                
               
                const distanceInfo = getShortestDistanceBetweenLines(
                    nodeEdgeStart.x, nodeEdgeStart.y, nodeEdgeEnd.x, nodeEdgeEnd.y,
                    otherEdgeStart.x, otherEdgeStart.y, otherEdgeEnd.x, otherEdgeEnd.y
                );
                
               
                if (distanceInfo.distance < minLineDistance && distanceInfo.distance > 0) {
                    const separationForce = calculateLineSeparationForce(
                        node, nodeEdgeStart, nodeEdgeEnd, otherEdgeStart, otherEdgeEnd,
                        distanceInfo, minLineDistance, forceStrength
                    );
                    
                    fx += separationForce.x;
                    fy += separationForce.y;
                }
            });
        });
        
        return {x: fx, y: fy};
    }
    
    
    function getShortestDistanceBetweenLines(x1, y1, x2, y2, x3, y3, x4, y4) {
       
        const dx1 = x2 - x1;
        const dy1 = y2 - y1;
        const length1Sq = dx1 * dx1 + dy1 * dy1;
        
       
        const dx2 = x4 - x3;
        const dy2 = y4 - y3;
        const length2Sq = dx2 * dx2 + dy2 * dy2;
        
        if (length1Sq === 0 || length2Sq === 0) {
            return {distance: Infinity};
        }
        
        let minDistance = Infinity;
        let closestPoint1 = null;
        let closestPoint2 = null;
        
       
        const candidates = [
           
            {p1: {x: x1, y: y1}, line2: [[x3, y3], [x4, y4]]},
            {p1: {x: x2, y: y2}, line2: [[x3, y3], [x4, y4]]},
           
            {p1: {x: x3, y: y3}, line2: [[x1, y1], [x2, y2]]},
            {p1: {x: x4, y: y4}, line2: [[x1, y1], [x2, y2]]},
        ];
        
        candidates.forEach(candidate => {
            const distance = pointToLineSegmentDistance(
                candidate.p1.x, candidate.p1.y,
                candidate.line2[0][0], candidate.line2[0][1],
                candidate.line2[1][0], candidate.line2[1][1]
            );
            
            if (distance.distance < minDistance) {
                minDistance = distance.distance;
                closestPoint1 = candidate.p1;
                closestPoint2 = distance.closestPoint;
            }
        });
        
       
        const cross = dx1 * dy2 - dy1 * dx2;
        if (Math.abs(cross) < 1e-6) {
            const perpDistance = Math.abs((x3 - x1) * dy1 - (y3 - y1) * dx1) / Math.sqrt(length1Sq);
            if (perpDistance < minDistance) {
                minDistance = perpDistance;
               
                const midX1 = (x1 + x2) / 2;
                const midY1 = (y1 + y2) / 2;
                const midX2 = (x3 + x4) / 2;
                const midY2 = (y3 + y4) / 2;
                closestPoint1 = {x: midX1, y: midY1};
                closestPoint2 = {x: midX2, y: midY2};
            }
        }
        
        return {
            distance: minDistance,
            point1: closestPoint1,
            point2: closestPoint2
        };
    }
    
    
    function pointToLineSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSq = dx * dx + dy * dy;
        
        if (lengthSq === 0) {
           
            const dist = Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            return {distance: dist, closestPoint: {x: x1, y: y1}};
        }
        
       
        const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));
        
       
        const closestX = x1 + t * dx;
        const closestY = y1 + t * dy;
        
       
        const distance = Math.sqrt((px - closestX) * (px - closestX) + (py - closestY) * (py - closestY));
        
        return {
            distance: distance,
            closestPoint: {x: closestX, y: closestY}
        };
    }
    
    
    function calculateLineSeparationForce(node, edge1Start, edge1End, edge2Start, edge2End, distanceInfo, minDistance, forceStrength) {
        if (!distanceInfo.point1 || !distanceInfo.point2) {
            return {x: 0, y: 0};
        }
        
       
        const separationX = distanceInfo.point2.x - distanceInfo.point1.x;
        const separationY = distanceInfo.point2.y - distanceInfo.point1.y;
        const separationLength = Math.sqrt(separationX * separationX + separationY * separationY);
        
        if (separationLength === 0) return {x: 0, y: 0};
        
       
        const normalizedX = separationX / separationLength;
        const normalizedY = separationY / separationLength;
        
       
        const requiredSeparation = minDistance - distanceInfo.distance;
        
       
        const forceIntensity = forceStrength * requiredSeparation / minDistance;
        
        let fx = 0, fy = 0;
        
       
       
        const distToPoint1 = Math.sqrt((node.x - distanceInfo.point1.x) ** 2 + (node.y - distanceInfo.point1.y) ** 2);
        const distToPoint2 = Math.sqrt((node.x - distanceInfo.point2.x) ** 2 + (node.y - distanceInfo.point2.y) ** 2);
        
        if (distToPoint1 < distToPoint2) {
           
            fx -= normalizedX * forceIntensity;
            fy -= normalizedY * forceIntensity;
        } else {
           
            fx += normalizedX * forceIntensity;
            fy += normalizedY * forceIntensity;
        }
        
       
       
        const edge1DirX = edge1End.x - edge1Start.x;
        const edge1DirY = edge1End.y - edge1Start.y;
        const edge1Length = Math.sqrt(edge1DirX * edge1DirX + edge1DirY * edge1DirY);
        
        if (edge1Length > 0) {
           
            const perpX = -edge1DirY / edge1Length;
            const perpY = edge1DirX / edge1Length;
            
           
            const toEdge2X = (edge2Start.x + edge2End.x) / 2 - (edge1Start.x + edge1End.x) / 2;
            const toEdge2Y = (edge2Start.y + edge2End.y) / 2 - (edge1Start.y + edge1End.y) / 2;
            
           
            const perpDot = perpX * toEdge2X + perpY * toEdge2Y;
            const perpForceX = perpX * Math.sign(-perpDot) * forceIntensity * 0.5;
            const perpForceY = perpY * Math.sign(-perpDot) * forceIntensity * 0.5;
            
            fx += perpForceX;
            fy += perpForceY;
        }
        
        return {x: fx, y: fy};
    }
    
    
    function analyzeEdgeCrossings(s) {
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        let crossings = 0;
        const crossingPairs = [];
        
       
        for (let i = 0; i < edges.length; i++) {
            for (let j = i + 1; j < edges.length; j++) {
                const edge1 = edges[i];
                const edge2 = edges[j];
                
               
                if (edge1.source === edge2.source || edge1.source === edge2.target || 
                    edge1.target === edge2.source || edge1.target === edge2.target) {
                    continue;
                }
                
                const edge1Start = nodes.find(n => n.id === edge1.source);
                const edge1End = nodes.find(n => n.id === edge1.target);
                const edge2Start = nodes.find(n => n.id === edge2.source);
                const edge2End = nodes.find(n => n.id === edge2.target);
                
                if (!edge1Start || !edge1End || !edge2Start || !edge2End) continue;
                
                const intersection = getLineIntersection(
                    edge1Start.x, edge1Start.y, edge1End.x, edge1End.y,
                    edge2Start.x, edge2Start.y, edge2End.x, edge2End.y
                );
                
                if (intersection.intersects) {
                    crossings++;
                    crossingPairs.push({
                        edge1: edge1,
                        edge2: edge2,
                        intersection: intersection
                    });
                }
            }
        }
        
        const totalPossibleCrossings = edges.length * (edges.length - 1) / 2;
        const crossingRate = totalPossibleCrossings > 0 ? (crossings / totalPossibleCrossings) * 100 : 0;
        
        return {
            crossings: crossings,
            crossingRate: crossingRate,
            crossingPairs: crossingPairs
        };
    }
    
    
    function analyzeEdgeSpacing(s) {
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        const minDesiredDistance = 15;
        let tooCloseCount = 0;
        let totalDistance = 0;
        let distancePairs = 0;
        const closeEdgePairs = [];
        
       
        for (let i = 0; i < edges.length; i++) {
            for (let j = i + 1; j < edges.length; j++) {
                const edge1 = edges[i];
                const edge2 = edges[j];
                
               
                if (edge1.source === edge2.source || edge1.source === edge2.target || 
                    edge1.target === edge2.source || edge1.target === edge2.target) {
                    continue;
                }
                
                const edge1Start = nodes.find(n => n.id === edge1.source);
                const edge1End = nodes.find(n => n.id === edge1.target);
                const edge2Start = nodes.find(n => n.id === edge2.source);
                const edge2End = nodes.find(n => n.id === edge2.target);
                
                if (!edge1Start || !edge1End || !edge2Start || !edge2End) continue;
                
                const distanceInfo = getShortestDistanceBetweenLines(
                    edge1Start.x, edge1Start.y, edge1End.x, edge1End.y,
                    edge2Start.x, edge2Start.y, edge2End.x, edge2End.y
                );
                
                if (distanceInfo.distance !== Infinity) {
                    totalDistance += distanceInfo.distance;
                    distancePairs++;
                    
                    if (distanceInfo.distance < minDesiredDistance) {
                        tooCloseCount++;
                        closeEdgePairs.push({
                            edge1: edge1,
                            edge2: edge2,
                            distance: distanceInfo.distance
                        });
                    }
                }
            }
        }
        
        const averageDistance = distancePairs > 0 ? totalDistance / distancePairs : 0;
        
        return {
            tooClose: tooCloseCount,
            averageDistance: averageDistance,
            closeEdgePairs: closeEdgePairs,
            totalPairs: distancePairs
        };
    }
    
    
    function performFinalCrossingOptimization(s, initialCrossings) {
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        const allNodes = nodes;
        const queryNodes = nodes.filter(node => node.isOriginalQuery);
        
        if (allNodes.length === 0) {
            console.log('No nodes to optimize edge crossings');
            return;
        }
        
       
        let queryCentroid = { x: 0, y: 0 };
        const queryConstraints = new Map();
        
        if (queryNodes.length > 0) {
            queryCentroid.x = queryNodes.reduce((sum, node) => sum + node.x, 0) / queryNodes.length;
            queryCentroid.y = queryNodes.reduce((sum, node) => sum + node.y, 0) / queryNodes.length;
            
           
            queryNodes.forEach(node => {
                const relativeX = node.x - queryCentroid.x;
                const relativeY = node.y - queryCentroid.y;
                const distance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);
                const angle = Math.atan2(relativeY, relativeX);
                
                queryConstraints.set(node.id, { distance, angle });
            });
        }
        
        const maxOptimizationIterations = 5;
        let currentCrossings = initialCrossings;
        
        for (let iter = 0; iter < maxOptimizationIterations; iter++) {
            console.log(`Edge crossing optimization iteration ${iter + 1}/${maxOptimizationIterations}...`);
            
           
            allNodes.forEach(node => {
                const originalX = node.x;
                const originalY = node.y;
                const currentNodeCrossings = countNodeRelatedCrossings(node, nodes, edges);
                
                if (currentNodeCrossings === 0) return;
                
                let bestX = originalX;
                let bestY = originalY;
                let bestCrossings = currentNodeCrossings;
                
               
                const moveRadius = node.isOriginalQuery ? 10 : 20;
                const testPositions = 8;
                
                for (let i = 0; i < testPositions; i++) {
                    const angle = (i * 2 * Math.PI) / testPositions;
                    const testX = originalX + Math.cos(angle) * moveRadius;
                    const testY = originalY + Math.sin(angle) * moveRadius;
                    
                   
                    node.x = testX;
                    node.y = testY;
                    
                   
                    let hasOverlap = false;
                    for (const otherNode of nodes) {
                        if (otherNode.id === node.id) continue;
                        
                        const dx = otherNode.x - node.x;
                        const dy = otherNode.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minRequired = (node.size || 8) + (otherNode.size || 8) + 10;
                        
                        if (distance < minRequired) {
                            hasOverlap = true;
                            break;
                        }
                    }
                    
                    if (!hasOverlap) {
                        const testCrossings = countNodeRelatedCrossings(node, nodes, edges);
                        if (testCrossings < bestCrossings) {
                            bestX = testX;
                            bestY = testY;
                            bestCrossings = testCrossings;
                        }
                    }
                }
                
               
                node.x = bestX;
                node.y = bestY;
                
                if (bestCrossings < currentNodeCrossings) {
                    console.log(`Node ${node.id} crossings reduced from ${currentNodeCrossings} to ${bestCrossings}`);
                }
            });
            
           
            if (queryNodes.length > 0) {
               
                const currentCentroid = {
                    x: queryNodes.reduce((sum, node) => sum + node.x, 0) / queryNodes.length,
                    y: queryNodes.reduce((sum, node) => sum + node.y, 0) / queryNodes.length
                };
                
               
                queryNodes.forEach(node => {
                    const constraint = queryConstraints.get(node.id);
                    if (constraint) {
                       
                        const idealX = currentCentroid.x + Math.cos(constraint.angle) * constraint.distance;
                        const idealY = currentCentroid.y + Math.sin(constraint.angle) * constraint.distance;
                        
                       
                        const correctionStrength = 0.3;
                        node.x += (idealX - node.x) * correctionStrength;
                                                 node.y += (idealY - node.y) * correctionStrength;
                     }
                 });
             }
            
           
            const newStats = analyzeEdgeCrossings(s);
            console.log(`[DEBUG] 总交叉数: ${currentCrossings} -> ${newStats.crossings}`);
            
            if (newStats.crossings >= currentCrossings) {
                console.log('[DEBUG] 交叉数未改善，停止优化');
                break;
            }
            
            currentCrossings = newStats.crossings;
            s.refresh();
            
            if (currentCrossings === 0) {
                console.log('[DEBUG] 已消除所有边交叉！');
                break;
            }
        }
        
        const finalStats = analyzeEdgeCrossings(s);
        console.log(`[DEBUG] 边交叉优化完成: ${initialCrossings} -> ${finalStats.crossings} (减少了 ${((initialCrossings - finalStats.crossings) / Math.max(initialCrossings, 1) * 100).toFixed(1)}%)`);
    }
    
    
    function countNodeRelatedCrossings(node, allNodes, allEdges) {
        let crossings = 0;
        
       
        const nodeEdges = allEdges.filter(edge => 
            edge.source === node.id || edge.target === node.id
        );
        
       
        nodeEdges.forEach(nodeEdge => {
            const nodeEdgeStart = allNodes.find(n => n.id === nodeEdge.source);
            const nodeEdgeEnd = allNodes.find(n => n.id === nodeEdge.target);
            
            if (!nodeEdgeStart || !nodeEdgeEnd) return;
            
            allEdges.forEach(otherEdge => {
               
                if (nodeEdge.source === otherEdge.source || 
                    nodeEdge.source === otherEdge.target || 
                    nodeEdge.target === otherEdge.source || 
                    nodeEdge.target === otherEdge.target) {
                    return;
                }
                
                const otherEdgeStart = allNodes.find(n => n.id === otherEdge.source);
                const otherEdgeEnd = allNodes.find(n => n.id === otherEdge.target);
                
                if (!otherEdgeStart || !otherEdgeEnd) return;
                
                const intersection = getLineIntersection(
                    nodeEdgeStart.x, nodeEdgeStart.y, nodeEdgeEnd.x, nodeEdgeEnd.y,
                    otherEdgeStart.x, otherEdgeStart.y, otherEdgeEnd.x, otherEdgeEnd.y
                );
                
                if (intersection.intersects) {
                    crossings++;
                }
            });
        });
        
        return crossings / 2;
    }
    
    
    function performFinalSpacingOptimization(s, initialTooClose) {
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        const allNodes = nodes;
        
        if (allNodes.length === 0) {
            console.log('没有节点可以优化线条间距');
            return;
        }
        
        const maxOptimizationIterations = 3;
        let currentTooClose = initialTooClose;
        
        for (let iter = 0; iter < maxOptimizationIterations; iter++) {
            console.log(`[DEBUG] 线条间距优化迭代 ${iter + 1}/${maxOptimizationIterations}...`);
            
            const spacingStats = analyzeEdgeSpacing(s);
            
           
            spacingStats.closeEdgePairs.forEach(pair => {
                const edge1 = pair.edge1;
                const edge2 = pair.edge2;
                
               
                const edge1Nodes = [
                    nodes.find(n => n.id === edge1.source),
                    nodes.find(n => n.id === edge1.target)
                ].filter(n => n);
                
                const edge2Nodes = [
                    nodes.find(n => n.id === edge2.source),
                    nodes.find(n => n.id === edge2.target)
                ].filter(n => n);
                
               
                const edge1Start = nodes.find(n => n.id === edge1.source);
                const edge1End = nodes.find(n => n.id === edge1.target);
                const edge2Start = nodes.find(n => n.id === edge2.source);
                const edge2End = nodes.find(n => n.id === edge2.target);
                
                if (!edge1Start || !edge1End || !edge2Start || !edge2End) return;
                
                const edge1CenterX = (edge1Start.x + edge1End.x) / 2;
                const edge1CenterY = (edge1Start.y + edge1End.y) / 2;
                const edge2CenterX = (edge2Start.x + edge2End.x) / 2;
                const edge2CenterY = (edge2Start.y + edge2End.y) / 2;
                
               
                const separationX = edge2CenterX - edge1CenterX;
                const separationY = edge2CenterY - edge1CenterY;
                const separationLength = Math.sqrt(separationX * separationX + separationY * separationY);
                
                if (separationLength > 0) {
                    const normalizedX = separationX / separationLength;
                    const normalizedY = separationY / separationLength;
                    
                    const moveDistance = (15 - pair.distance) / 2;
                    
                   
                    edge1Nodes.forEach(node => {
                        node.x -= normalizedX * moveDistance;
                        node.y -= normalizedY * moveDistance;
                    });
                    
                   
                    edge2Nodes.forEach(node => {
                        node.x += normalizedX * moveDistance;
                        node.y += normalizedY * moveDistance;
                    });
                }
            });
            
           
            const hasOverlap = checkForNodeOverlaps(nodes);
            if (hasOverlap) {
                console.log('[DEBUG] 移动产生了节点重叠，执行修正...');
                enforceMinimumDistance(nodes, 10);
            }
            
           
            const newSpacingStats = analyzeEdgeSpacing(s);
            console.log(`[DEBUG] 过近线条对: ${currentTooClose} -> ${newSpacingStats.tooClose}`);
            
            if (newSpacingStats.tooClose >= currentTooClose) {
                console.log('[DEBUG] 线条间距未改善，停止优化');
                break;
            }
            
            currentTooClose = newSpacingStats.tooClose;
            s.refresh();
            
            if (currentTooClose === 0) {
                console.log('[DEBUG] 所有线条间距已达到要求！');
                break;
            }
        }
        
        const finalSpacingStats = analyzeEdgeSpacing(s);
        console.log(`[DEBUG] 线条间距优化完成: ${initialTooClose} -> ${finalSpacingStats.tooClose} (改善了 ${((initialTooClose - finalSpacingStats.tooClose) / Math.max(initialTooClose, 1) * 100).toFixed(1)}%)`);
    }
    
    
    function checkForNodeOverlaps(nodes) {
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const node1 = nodes[i];
                const node2 = nodes[j];
                
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minRequired = (node1.size || 8) + (node2.size || 8) + 8;
                
                if (distance < minRequired) {
                    return true;
                }
            }
        }
        return false;
    }

    
    function enforceMinimumDistance(nodes, minDistance) {
       
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const node1 = nodes[i];
                const node2 = nodes[j];
                
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const node1Radius = (node1.size || 8) / 2;
                const node2Radius = (node2.size || 8) / 2;
                const requiredDistance = node1Radius + node2Radius + minDistance;
                
                if (distance < requiredDistance && distance > 0) {
                    const separation = requiredDistance - distance;
                    
                   
                    const node1Scale = 1.0;
                    const node2Scale = 1.0;
                    const totalScale = node1Scale + node2Scale;
                    
                    const moveX = (dx / distance) * separation * 0.5;
                    const moveY = (dy / distance) * separation * 0.5;
                    
                   
                    node1.x -= moveX * (node1Scale / totalScale);
                    node1.y -= moveY * (node1Scale / totalScale);
                    node2.x += moveX * (node2Scale / totalScale);
                    node2.y += moveY * (node2Scale / totalScale);
                }
            }
        }
    }
    
    
    function performFinalOverlapResolution(s) {
        console.log('[DEBUG] Performing enhanced final overlap resolution...');
        
        const nodes = s.graph.nodes();
        const allNodes = [...nodes];
        const totalNodes = allNodes.length;
        const currentNodeSize = s.nodeSize || RESULT_NODE_SIZE;
        
       
        let minSeparation, maxIterations;
        
       
        const baseMultiplier = totalNodes > 20 ? 1.8 : totalNodes > 15 ? 2.0 : totalNodes > 12 ? 2.2 : 2.5;
        minSeparation = Math.max(6, currentNodeSize * baseMultiplier);
        
        if (totalNodes > 20) {
            maxIterations = 10;
            console.log(`[DEBUG] 超大型图重叠解决: 节点大小=${currentNodeSize}, 间距=${minSeparation.toFixed(1)}, 迭代=${maxIterations}`);
        } else if (totalNodes > 15) {
            maxIterations = 8;
            console.log(`[DEBUG] 大型图重叠解决: 节点大小=${currentNodeSize}, 间距=${minSeparation.toFixed(1)}, 迭代=${maxIterations}`);
        } else if (totalNodes > 12) {
            maxIterations = 6;
            console.log(`[DEBUG] 中大型图重叠解决: 节点大小=${currentNodeSize}, 间距=${minSeparation.toFixed(1)}, 迭代=${maxIterations}`);
        } else {
            maxIterations = 5;
            console.log(`[DEBUG] 中小型图重叠解决: 节点大小=${currentNodeSize}, 间距=${minSeparation.toFixed(1)}, 迭代=${maxIterations}`);
        }
        
       
        let totalOverlaps = 0;
        
       
        for (let iter = 0; iter < maxIterations; iter++) {
            let hasOverlap = false;
            let iterationOverlaps = 0;
            
           
            for (let i = 0; i < allNodes.length; i++) {
                for (let j = i + 1; j < allNodes.length; j++) {
                    const node1 = allNodes[i];
                    const node2 = allNodes[j];
                    
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                   
                    const baseSize = 10;
                    const node1Radius = (node1.size || baseSize) / 2;
                    const node2Radius = (node2.size || baseSize) / 2;
                    const requiredDistance = node1Radius + node2Radius + minSeparation;
                    
                    if (distance < requiredDistance) {
                        hasOverlap = true;
                        iterationOverlaps++;
                        
                        if (distance === 0) {
                           
                            const randomAngle = Math.random() * 2 * Math.PI;
                            const randomDistance = requiredDistance + Math.random() * 10;
                            
                            const moveX = Math.cos(randomAngle) * randomDistance * 0.5;
                            const moveY = Math.sin(randomAngle) * randomDistance * 0.5;
                            
                           
                            const node1Scale = 1.0;
                            const node2Scale = 1.0;
                            const totalScale = node1Scale + node2Scale;
                            
                            node1.x -= moveX * (node1Scale / totalScale);
                            node1.y -= moveY * (node1Scale / totalScale);
                            node2.x += moveX * (node2Scale / totalScale);
                            node2.y += moveY * (node2Scale / totalScale);
                        } else {
                           
                            const overlap = requiredDistance - distance;
                            const moveDistance = overlap * 0.8;
                            
                            const moveX = (dx / distance) * moveDistance * 0.5;
                            const moveY = (dy / distance) * moveDistance * 0.5;
                            
                           
                            const node1Scale = 1.0;
                            const node2Scale = 1.0;
                            const totalScale = node1Scale + node2Scale;
                            
                           
                            node1.x -= moveX * (node1Scale / totalScale);
                            node1.y -= moveY * (node1Scale / totalScale);
                            node2.x += moveX * (node2Scale / totalScale);
                            node2.y += moveY * (node2Scale / totalScale);
                        }
                    }
                }
            }
            
            console.log(`[DEBUG] 迭代 ${iter + 1}: 发现 ${iterationOverlaps} 个重叠`);
            totalOverlaps += iterationOverlaps;
            
            if (!hasOverlap) {
                console.log(`[DEBUG] 重叠解决在 ${iter + 1} 次迭代后完成`);
                break;
            }
            
           
            s.refresh();
        }
        
       
        let finalOverlaps = 0;
        for (let i = 0; i < allNodes.length; i++) {
            for (let j = i + 1; j < allNodes.length; j++) {
                const node1 = allNodes[i];
                const node2 = allNodes[j];
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const requiredDistance = (node1.size || 10) / 2 + (node2.size || 10) / 2 + minSeparation;
                
                if (distance < requiredDistance) {
                    finalOverlaps++;
                }
            }
        }
        
        s.refresh();
        console.log(`[DEBUG] 重叠解决完成！处理了 ${totalOverlaps} 个重叠，剩余 ${finalOverlaps} 个`);
        
        if (finalOverlaps > 0) {
            console.warn(`[DEBUG] 仍有 ${finalOverlaps} 个节点重叠，可能需要手动调整`);
        }
    }

    function drawQueriedPattern(s, pattern) {
        console.log(s, pattern)
        let gap = PATTERN_NODE_SIZE * 5;
        
       
        const totalNodes = pattern.nodes.length;
        let nodeSize = RESULT_NODE_SIZE;
        
        console.log(`[DEBUG] Total nodes: ${totalNodes}, adjusting layout parameters...`);
        
        if (totalNodes >= 15) {
           
            nodeSize = RESULT_NODE_SIZE;
            gap = PATTERN_NODE_SIZE * 4;
            console.log(`[DEBUG] 大型图 (${totalNodes}节点): 保持标准大小=${nodeSize}, 间距=${gap}`);
        } else if (totalNodes > 12) {
           
            nodeSize = Math.max(6, RESULT_NODE_SIZE * 0.6);
            gap = PATTERN_NODE_SIZE * 4;
            console.log(`[DEBUG] 中大型图 (${totalNodes}节点): 节点大小=${nodeSize}, 间距=${gap}`);
        } else if (totalNodes > 8) {
           
            nodeSize = Math.max(7, RESULT_NODE_SIZE * 0.8);
            gap = PATTERN_NODE_SIZE * 4.5;
            console.log(`[DEBUG] 中型图 (${totalNodes}节点): 节点大小=${nodeSize}, 间距=${gap}`);
        } else {
           
            console.log(`[DEBUG] 小型图 (${totalNodes}节点): 使用默认大小`);
        }
        
       
        s.nodeSize = nodeSize;
        
       
        let currentQueryNodes = new Set();
        
               
        if (window.sigma_constructor && window.sigma_constructor.graph) {
            const constructorNodes = window.sigma_constructor.graph.nodes();
            constructorNodes.forEach(node => {
               
                currentQueryNodes.add(node.id);
                currentQueryNodes.add(node.id.toString());
                currentQueryNodes.add(parseInt(node.id));
            });
            console.log(`[DEBUG] 从构造器获取当前查询图节点: ${constructorNodes.length} 个`);
            console.log('[DEBUG] 构造器节点详情:', constructorNodes.map(n => `ID:${n.id}, 标签:${n.label || n.atomicLabel}`));
        } else {
           
        const originalQuery = getOriginalQueryNodes();
           
            if (originalQuery.nodes) {
                if (originalQuery.nodes instanceof Set) {
                    currentQueryNodes = originalQuery.nodes;
                } else {
                   
                    Object.keys(originalQuery.nodes).forEach(nodeId => {
                        currentQueryNodes.add(nodeId);
                    });
                }
                console.log(`[DEBUG] 使用保存的查询快照: ${currentQueryNodes.size} 个节点`);
            }
        }
        
       
        const queryNodes = [];
        const newNodes = [];
        
        console.log('[DEBUG] === 开始节点分类调试 ===');
        console.log('[DEBUG] 构造器中的节点ID集合:', Array.from(currentQueryNodes));
        console.log('[DEBUG] TED结果中的节点:');
        
        pattern.nodes.forEach((node, i) => {
            const numericLabel = node.label.toString();
            const atomicLabel = getCurrentReverseAtomicLabels()[numericLabel] || numericLabel;
            
            console.log(`[DEBUG] 节点 ${i}: ID=${node.id}, 标签=${numericLabel}(${atomicLabel})`);
            
           
            let isQueryNode = false;
            
           
            if (currentQueryNodes.has(node.id)) {
                isQueryNode = true;
                console.log(`[DEBUG] 通过ID匹配确认为查询图节点`);
            } else {
               
               
                if (window.sigma_constructor && window.sigma_constructor.graph) {
                    const constructorNodes = window.sigma_constructor.graph.nodes();
                    
                   
                    const originalConstructorNode = constructorNodes.find(cNode => cNode.id === node.id);
                    if (originalConstructorNode) {
                        const originalLabel = originalConstructorNode.label || originalConstructorNode.atomicLabel;
                        console.log(`[DEBUG] 发现ID ${node.id} 在构造器中存在，原标签=${originalLabel}, 结果标签=${atomicLabel}`);
                        
                       
                        isQueryNode = true;
                    }
                }
            }
            
            if (isQueryNode) {
                queryNodes.push({node, index: i});
            } else {
                newNodes.push({node, index: i});
                console.log(`[DEBUG] 分类为新增节点 (ID和标签都不匹配原查询图)`);
            }
        });
        
        const queryNodePositions = {};
       
        if (queryNodes.length > 0) {
           
            let constructorGraph = null;
            
           
            if (window.sigma_constructor && window.sigma_constructor.graph) {
                constructorGraph = window.sigma_constructor;
                console.log('[DEBUG] 通过 window.sigma_constructor 获取构造器');
            }
           
            else if ($('.sigma-query-constructor').length > 0) {
                const constructorDiv = $('.sigma-query-constructor').first();
                constructorGraph = constructorDiv.data('sigmaObject');
                console.log('[DEBUG] 通过 DOM 查找获取构造器');
            }
           
            else if (currentQuerySnapshot && currentQuerySnapshot.nodes) {
                console.log('[DEBUG] 使用保存的查询快照获取坐标');
                Object.keys(currentQuerySnapshot.nodes).forEach(nodeId => {
                    const nodeData = currentQuerySnapshot.nodes[nodeId];
                    if (currentQueryNodes.has(nodeId)) {
                       
                        const defaultConstructorSize = PATTERN_NODE_SIZE;
                        const resultNodeSize = nodeSize;
                        const scaleFactor = Math.min(0.8, resultNodeSize / defaultConstructorSize * 0.7);
                        
                        queryNodePositions[nodeId] = {
                            x: nodeData.x * scaleFactor,
                            y: nodeData.y * scaleFactor
                        };
                        console.log(`[DEBUG] 从快照获取查询节点 ${nodeId}: (${nodeData.x.toFixed(1)}, ${nodeData.y.toFixed(1)}) -> (${queryNodePositions[nodeId].x.toFixed(1)}, ${queryNodePositions[nodeId].y.toFixed(1)}) [缩放=${scaleFactor.toFixed(2)}]`);
                    }
                });
            }
            
           
            if (constructorGraph && constructorGraph.graph) {
                console.log(`[DEBUG] 构造器实例有效，节点数量: ${constructorGraph.graph.nodes().length}`);
                
                constructorGraph.graph.nodes().forEach(constructorNode => {
                    if (currentQueryNodes.has(constructorNode.id)) {
                       
                       
                        const constructorNodeSize = constructorGraph.nodeSize || PATTERN_NODE_SIZE;
                        const resultNodeSize = nodeSize;
                        const scaleFactor = Math.min(0.8, resultNodeSize / constructorNodeSize * 0.7);
                        
                        queryNodePositions[constructorNode.id] = {
                            x: constructorNode.x * scaleFactor,
                            y: constructorNode.y * scaleFactor
                        };
                        
                        console.log(`[DEBUG] 查询节点 ${constructorNode.id}: 构造器(${constructorNode.x.toFixed(1)}, ${constructorNode.y.toFixed(1)}) -> 结果图(${queryNodePositions[constructorNode.id].x.toFixed(1)}, ${queryNodePositions[constructorNode.id].y.toFixed(1)}) [缩放=${scaleFactor.toFixed(2)}]`);
                    }
                });
            }
            
            console.log(`[DEBUG] 成功提取 ${Object.keys(queryNodePositions).length} 个查询图节点位置`);
            console.log('[DEBUG] 查询图位置详情:', queryNodePositions);
            console.log('[DEBUG] === 查询图坐标提取完成 ===');
            
           
            if (Object.keys(queryNodePositions).length === 0) {
                console.warn('[DEBUG] 未能获取任何查询图节点位置，将使用默认布局');
            }
        }
        
       
        queryNodes.forEach(({node, index}) => {
            const numericLabel = node.label.toString();
            const atomicLabel = getCurrentReverseAtomicLabels()[numericLabel] || numericLabel;
            
                         let x, y;
             if (queryNodePositions[node.id]) {
                
                 x = queryNodePositions[node.id].x;
                 y = queryNodePositions[node.id].y;
                 console.log(`[DEBUG] Using constructor position for query node ${node.id}: (${x.toFixed(2)}, ${y.toFixed(2)})`);
                          } else {
                  console.warn(`[DEBUG] No position found for query node ${node.id}, using fallback layout`);
                 
                  x = (index % 3) * gap - gap;
                  y = Math.floor(index / 3) * gap - gap;
                  console.log(`[DEBUG] Using grid fallback for query node ${node.id}: (${x}, ${y})`);
             }
            
                         addNodeById(s, x, y, true, atomicLabel, node.id);
             
            
                const sigmaNode = s.graph.nodes().find(n => n.id === node.id);
                if (sigmaNode) {
                    sigmaNode.isOriginalQuery = true;
                
                
                 console.log(`[DEBUG] 查询图节点 ${node.id}(${atomicLabel}) 已放置在: (${x.toFixed(1)}, ${y.toFixed(1)})`);
             }
        });
        
       
        newNodes.forEach(({node, index}) => {
            const numericLabel = node.label.toString();
            const atomicLabel = getCurrentReverseAtomicLabels()[numericLabel] || numericLabel;
            
           
            const angle = (index * 2 * Math.PI) / Math.max(1, newNodes.length);
            const radius = gap * 1.3;
            const x = Math.cos(angle) * radius + (Math.random() - 0.5) * gap * 0.5;
            const y = Math.sin(angle) * radius + (Math.random() - 0.5) * gap * 0.5;
            
            console.log(`[DEBUG] 新节点 ${node.id} 紧凑初始位置: (${x.toFixed(2)}, ${y.toFixed(2)})`);
            
            addNodeById(s, x, y, true, atomicLabel, node.id);
            
           
            const sigmaNode = s.graph.nodes().find(n => n.id === node.id);
            if (sigmaNode) {
                sigmaNode.isNewNode = true;
                console.log(`[DEBUG] 标记节点 ${node.id} 为新增节点`);
            }
        });

       
        if (pattern.edges && pattern.edges.length > 0) {
           
            pattern.edges.forEach(edge => {
                const edgeType = edge.type || 0;
                addEdge(s, edge.source, edge.target, edgeType);
            });
        } else {
           
            pattern.e.forEach(pair => addEdge(s, pair[0], pair[1], 0));
        }
        
       
        if (newNodes.length > 0) {
            console.log('[DEBUG] Applying smart layout: fixing query nodes, layouting new nodes');
            
           
            applySmartLayout(s, 1000);
            
                    setTimeout(() => {
               
                drawQueryHighlight(s);
               
                rotateTofitContainer(s);
               
                scaleTofitContainer(s);
            }, 1200);
        } else {
            console.log('[DEBUG] No new nodes, skipping layout');
           
            setTimeout(() => {
               
                drawQueryHighlight(s);
                rotateTofitContainer(s);
               
                scaleTofitContainer(s);
            }, 100);
        }
    }

    
    function drawCustomizedHub(s, cX, cY, degree, firstDraw) {
        let angle = Math.PI * 2 / degree;
        let base = s.nodeCnt;
        addNode(s, cX, cY, true);
        let x = firstDraw ? -1 : -customizedHubRadius, y = 0;
        for (let i = 0; i < degree; ++i) {
            addNode(s, cX + x, cY + y, true);
            addEdge(s, base, base + i + 1, 0);
            [x, y] = [x * Math.cos(angle) - y * Math.sin(angle), x * Math.sin(angle) + y * Math.cos(angle)];
        }
        if (firstDraw) {
            scaleTofitContainer(s);
            customizedHubRadius = -s.graph.nodes()[1].x;
        } else {
            s.activeState.dropNodes();
            for (let i = 0; i < degree + 1; ++i)
                s.activeState.addNodes(base + i);
        }
        s.refresh();
                debouncedSaveQueryGraph();
    }

    
    function drawCustomizedRing(s, cX, cY, length, firstDraw) {
        let angle = Math.PI * 2 / length;
        let base = s.nodeCnt;
        let x = firstDraw ? -1 : -customizedRingRadius, y = 0;
        for (let i = 0; i < length; ++i) {
            addNode(s, cX + x, cY + y, true);
            [x, y] = [x * Math.cos(angle) - y * Math.sin(angle), x * Math.sin(angle) + y * Math.cos(angle)];
        }
        for (let i = 0; i < length; ++i)
            addEdge(s, base + i, i + 1 < length ? base + i + 1 : base, 0);
        if (firstDraw) {
            scaleTofitContainer(s);
            customizedRingRadius = -s.graph.nodes()[0].x;
        } else {
            s.activeState.dropNodes();
            for (let i = 0; i < length; ++i)
                s.activeState.addNodes(base + i);
        }
        s.refresh();
                debouncedSaveQueryGraph();
    }

    
    function generateLabelsPanel(labelsMap) {
       
        $('#nested-labels').empty();
        $('#plain-labels').empty();
        
       
        Object.entries(labelsMap).forEach(([label, id]) => {
           
            const atomicSymbol = label;
            
           
            const labelElement = $('<div>')
                .addClass('draggable-label-node')
                .attr('data-label-id', id)
                .attr('data-atomic-symbol', atomicSymbol)
                .attr('draggable', 'true')
                .css({
                    'display': 'flex',
                    'align-items': 'center',
                    'padding': '8px 12px',
                    'margin': '4px 0',
                    'border': '1px solid #dee2e6',
                    'border-radius': '4px',
                    'background-color': '#f8f9fa',
                    'cursor': 'grab',
                    'user-select': 'none',
                    'transition': 'all 0.2s ease'
                })
                .hover(
                    function() {
                        $(this).css({
                            'background-color': '#e9ecef',
                            'border-color': '#adb5bd',
                            'transform': 'translateY(-1px)',
                            'box-shadow': '0 2px 4px rgba(0,0,0,0.1)'
                        });
                    },
                    function() {
                        $(this).css({
                            'background-color': '#f8f9fa',
                            'border-color': '#dee2e6',
                            'transform': 'translateY(0)',
                            'box-shadow': 'none'
                        });
                    }
                );

           
            const nodeIcon = $('<div>')
                .css({
                    'width': '24px',
                    'height': '24px',
                    'border-radius': '50%',
                    'background-color': getNodeColorByLabel(atomicSymbol),
                    'border': '2px solid #666',
                    'margin-right': '10px',
                    'display': 'flex',
                    'align-items': 'center',
                    'justify-content': 'center',
                    'font-size': '10px',
                    'font-weight': 'bold',
                    'color': '#333',
                    'flex-shrink': '0'
                })
                .text(atomicSymbol);

           
            const labelText = $('<span>')
                .css({
                    'font-size': '13px',
                    'font-weight': '500',
                    'color': '#495057'
                })
                .text(atomicSymbol);

           
            const dragIcon = $('<i>')
                .addClass('fa fa-arrows')
                .css({
                    'margin-left': 'auto',
                    'color': '#6c757d',
                    'font-size': '12px'
                });

            labelElement.append(nodeIcon, labelText, dragIcon);

           
            labelElement.on('dragstart', function(e) {
                const originalEvent = e.originalEvent;
                originalEvent.dataTransfer.setData('text/plain', JSON.stringify({
                    type: 'label-node',
                    atomicSymbol: atomicSymbol,
                    labelId: id
                }));
                originalEvent.dataTransfer.effectAllowed = 'copy';
                $(this).css('opacity', '0.5');
                
               
                const dragImage = $(this).clone().css({
                    'position': 'absolute',
                    'top': '-1000px',
                    'background-color': '#fff',
                    'border': '2px solid #007bff',
                    'box-shadow': '0 4px 8px rgba(0,0,0,0.2)'
                });
                $('body').append(dragImage);
                originalEvent.dataTransfer.setDragImage(dragImage[0], 50, 25);
                setTimeout(() => dragImage.remove(), 0);
            });

           
            labelElement.on('dragend', function(e) {
                $(this).css('opacity', '1');
            });

           
            labelElement.on('click', function(e) {
                e.preventDefault();
                
               
                currentSelectedLabel = atomicSymbol;
                currentSelectedLabelId = id;
                
               
                $('#plain-labels .draggable-label-node').removeClass('selected');
                $(this).addClass('selected').css({
                    'background-color': '#cce5ff',
                    'border-color': '#007bff'
                });
                
                const selectedNodes = s.activeState.nodes();
                if (selectedNodes.length > 0) {
                   
                    selectedNodes.forEach(node => {
                        node.originalLabel = String(id);
                        node.label = atomicSymbol;
                       
                        node.color = getNodeColorByLabel(node.label);
                    });
                    s.refresh();
                   
                    stepCounter.inc('修改标签', `为${selectedNodes.length}个选中节点设置标签"${atomicSymbol}"`);
                } else {
                   
                    console.log(`Selected label: ${atomicSymbol} (ID: ${id}) - Drag to constructor or double-click canvas to add node`);
                }
            });
            
            $('#plain-labels').append(labelElement);
        });
        
       
        $('.card-footer').text(`${Object.keys(labelsMap).length} labels`);
        
       
        if (typeof resetLabelSearch === 'function') {
            resetLabelSearch();
        }
    }

    
    function groupLabels(labels) {
        if (0 == labels.length) return [];
        let ret = [];
        let queue = [[0, labels.length, ret]];
        while (queue.length > 0) {
            let [l, r, container] = queue.shift();
            let n = r - l;
            if (n <= 15) {
                for (let i = l; i < r; ++i)
                    container.push(labels[i]);
            } else {
                let gNum, gSize;
                if (n <= 100) {
                    gNum = Math.ceil(n / 10);
                    gSize = 10;
                } else {
                    gNum = 10;
                    gSize = Math.ceil(n / gNum);
                }
                if (1 <= n % 10 && n % 10 <= 3)
                    --gNum;
                let cl = l, cr;
                while (gNum-- > 0) {
                    cr = cl + gSize;
                    if (0 == gNum) cr = r;
                    let reRet = [];
                    container.push([`${labels[cl]} - ${labels[cr - 1]}`, reRet]);
                    queue.push([cl, cr, reRet]);
                    cl = cr;
                }
            }
        }
        return ret;
    }

    
    function drawNestedLabels(container, labels, depth) {
        labels.forEach(item => {
            if (Array.isArray(item)) {
                console.assert(2 == item.length, 'invalid labels array!!');
                let a = $('<a>', {
                    'href': `#label-${item[0]}`,
                    'class': `list-group-item ${depth > 0 ? 'inside-list-group-item' : ''}`,
                    'data-toggle': 'collapse',
                }).html(`<i class="fa fa-chevron-right"></i>${item[0]}`).appendTo(container);
                a.css('padding-left', `${10 + depth * 10}px`);
                drawNestedLabels($('<div>', {
                    'class': 'list-group collapse',
                    'id': `label-${item[0]}`
                }).appendTo(container), item[1], depth + 1);
            } else {
                let a = $('<a>', {
                    'href': 'javascript:void(0)',
                    'class': `list-group-item ${depth > 0 ? 'inside-list-group-item' : ''} list-group-item-action`
                }).text(`${item}`).appendTo(container);
                a.css('padding-left', `${20 + depth * 10}px`);
            }
        });
    }

    
    function drawPlainLabels(container, labels) {
        labels.forEach(label => {
            $('<a>', {
                'href': 'javascript:void(0)',
                'class': 'list-group-item list-group-item-action'
            }).text(label).appendTo(container);
        });
    }

    
    function addPattern(s, p, cX, cY) {
        let base = s.nodeCnt;
        console.log(p)
        p.graph.nodes().forEach(n => {
            let id = s.nodeCnt++;
            s.graph.addNode({
                id: id,
                size: s.nodeSize,
                x: cX + n.x,
                y: cY + n.y,
                label: n.label,
                color: n.color || getNodeColorByLabel(n.label), 
                borderColor: n.borderColor || '#666', 
                borderSize: n.borderSize || 2 
            });
        });
        p.graph.edges().forEach(e => {
            let id = s.edgeCnt++;
            s.graph.addEdge({
                id: id,
                source: base + e.source,
                target: base + e.target,
                size: s.edgeSize,
                type: e.type || 0, 
                color: e.color || getEdgeColor(e.type || 0) 
            });
        });

        s.activeState.dropNodes();
        p.graph.nodes().forEach((_, i) => s.activeState.addNodes(base + i));
        s.refresh();
                debouncedSaveQueryGraph();

       
       
       
        mappingTimeCounter.append((new Date() - lastTimeClickOnBoard) / 1000);
        lastTimeClickOnBoard = new Date();
        
       
        if (s === window.sigma_constructor) {
            updateNodeCounter();
        }
    }

    
    function scaleTillClear(s, nodes) {
        let num = nodes.length;
        while (true) {
            let clear = true;
            for (let i = 0; i + 1 < num && clear; ++i)
                for (let j = i + 1; j < num && clear; ++j)
                    if (Math.sqrt(Math.pow(nodes[i].x - nodes[j].x, 2) + Math.pow(nodes[i].y - nodes[j].y, 2)) < s.nodeSize * 5)
                        clear = false;
            if (clear)
                break;
            else
                scaleNodes(s, nodes, 1.1, true);
        }
    }

   

    function enableDoubleClick(sourceClass, s) {
        $.each($('.' + sourceClass), (_, c) => {
            $(c).dblclick(e => {
                console.log('🖱️🖱️ [DEBUG] Double click on pattern detected:', {
                    currentTarget: e.currentTarget,
                    targetId: e.currentTarget.id,
                    sourceClass: sourceClass
                });
                
                const sigmaObj = $(e.currentTarget).data('sigmaObject');
                console.log('🎯 [DEBUG] Double click - sigmaObj check:', {
                    sigmaObj: sigmaObj,
                    patternId: sigmaObj ? sigmaObj.patternId : 'undefined'
                });
                
                let p = s.camera.cameraPosition(0, 0);
                addPattern(s, $(e.currentTarget).data('sigmaObject'), p.x, p.y);
                scaleTillClear(s, s.activeState.nodes());
            debouncedSaveQueryGraph();
                
                console.log('🚫 [DEBUG] Double click - Pattern counting is DISABLED to prevent duplication');
                console.log('🚫 [DEBUG] Pattern should only be counted via drag event');
                
               
            })
        })
    }

    
    function enableDrag(sourceClass, s) {
        $.each($('.' + sourceClass), (_, c) => {
            $(c).draggable({
                helper: e => {
                    let clone = $(e.currentTarget).clone();
                   
                    clone.css({
                        width: '200px',
                        height: '130px'
                    });
                    clone.children('canvas.sigma-scene')[0].getContext('2d').drawImage($(e.currentTarget).children('canvas.sigma-scene')[0], 0, 0);
                    return clone;
                },
                appendTo: 'div.container-fluid',
                scroll: false,
                cursor: 'move',
                opacity: 1, 
                cursorAt: {
                    left: c.offsetWidth / 2,
                    top: c.offsetHeight / 2
                },
                start: e => {
                    console.log('dragstart', e);
                },
                stop: e => {
                    console.log('dragstop', e);
                    console.log(s)
                    console.log(e.target)
                    let rx = e.pageX - $(s.renderers[0].container).offset().left;
                    let ry = e.pageY - $(s.renderers[0].container).offset().top;
                    if (rx - c.offsetWidth / 2 > 0 && rx + c.offsetWidth / 2 < s.renderers[0].container.offsetWidth
                        && ry - c.offsetHeight / 2 > 0 && ry + c.offsetHeight / 2 < s.renderers[0].container.offsetHeight) {
                        console.log('add pattern');
                        let x = rx - s.sigmaMouse.offsetWidth / 2;
                        let y = ry - s.sigmaMouse.offsetHeight / 2;
                        let p = s.camera.cameraPosition(x, y);
                        
                       
                        const sigmaObj = $(e.target).data('sigmaObject');
                        console.log('🎯 [DEBUG] Drag stop - pattern counting check:', {
                            target: e.target,
                            targetId: e.target.id,
                            sigmaObj: sigmaObj,
                            patternId: sigmaObj ? sigmaObj.patternId : 'undefined'
                        });
                        
                        if (sigmaObj && sigmaObj.patternId) {
                            console.log('✅ [DEBUG] Pattern counted via DRAG:', sigmaObj.patternId);
                            console.log('📊 [DEBUG] Pattern counter before increment:', $('#pattern-count span').text());
                            patternCounter.inc(sigmaObj.patternId);
                            console.log('📊 [DEBUG] Pattern counter after increment:', $('#pattern-count span').text());
                            
                           
                            stepCounter.inc('拖拽模式', `从预设模式拖拽 ${sigmaObj.patternId} 到查询画布`);
                        } else {
                            console.log('❌ [DEBUG] Pattern NOT counted - missing sigmaObj or patternId');
                        }
                        
                        switch (e.target.id) {
                            case 'customized-hub-default-pattern':
                                addPatternCenter = {x: p.x, y: p.y};
                                $('#customized-hub-modal').modal('show');
                                break;
                            case 'customized-ring-default-pattern':
                                addPatternCenter = {x: p.x, y: p.y};
                                $('#customized-ring-modal').modal('show');
                                break;
                            default:
                                addPattern(s, $(e.target).data('sigmaObject'), p.x, p.y);
                                scaleTillClear(s, s.activeState.nodes());
            debouncedSaveQueryGraph();
                        }
                    }
                }
            });
        });
    }

    
    function generateQueryResult() {
       
        queryPatternSigmaObjects.forEach(s => {
           
            if (s._queryHighlightCleanup) {
                s._queryHighlightCleanup();
            }
            
           
            const container = s.renderers[0] && s.renderers[0].container;
            if (container) {
                const svg = container.querySelector('.query-highlight-svg');
                if (svg) {
                    svg.remove();
                }
            }
            s.kill();
        });
        queryPatternSigmaObjects = [];
        
        let queryPatternsRow = $('#query-patterns-list');
        queryPatternsRow.empty();
        
        if(queryResults.length === 0) {
            queryPatternsRow.text("No patterns found");
            return;
        }

       
        $('.modern-stats').show();
        $('#result-timer').text($('#timer span').text());
        $('#result-step-count').text($('#step-count span').text().replace(/\D/g, ''));
        $('#result-pattern-count').text($('#pattern-count span').text().replace(/\D/g, ''));
        
        queryResults.forEach((result, index) => {
           
            let div = $('<div>', {
                class: 'sigma-query-result-board',
                title: `Match ${index + 1} - Click to copy to constructor`,
                style: 'cursor: pointer;'
            });
            div.appendTo(queryPatternsRow);
            
           
            let s = new sigma({
                renderers: [{
                    container: div.get(0),
                    type: 'canvas'
                }],
                settings: patternSigmaSettings
            });
            
           
            s.nodeCnt = 0;
            s.edgeCnt = 0;
            s.nodeSize = RESULT_NODE_SIZE;
            s.edgeSize = RESULT_EDGE_SIZE;
            s.patternId = `Match ${index + 1}`;
            div.data('sigmaObject', s);
            div.data('resultData', result);
            
           
            const pattern = {
                n: result.nodes.length,
                nodes: result.nodes,
                e: result.edges.map(edge => [edge.source, edge.target]),
                edges: result.edges
            };
            drawQueriedPattern(s, pattern);
            
            queryPatternSigmaObjects.push(s);
        });
        
       
        setTimeout(() => {
            enableQueryResultClick();
        }, 200);
    }

    
    function enableQueryResultClick() {
        console.log('Enabling click events for query results...');
        
       
        $('.sigma-query-result-board').off('click mousedown');
        
       
        $('.sigma-query-result-board').each(function(index) {
            const $div = $(this);
            const resultData = $div.data('resultData');
            
            console.log(`Setting up click for result ${index}:`, resultData);
            
           
            $div.on('mouseenter', function() {
                $(this).css('opacity', '0.8');
            }).on('mouseleave', function() {
                $(this).css('opacity', '1');
            });
            
           
            $div.on('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Query result clicked:', index, resultData);
                
                if (resultData) {
                    copyGraphToConstructor(resultData);
                } else {
                    console.error('No result data found for clicked item');
                }
            });
            
           
            const canvas = $div.find('canvas');
            canvas.on('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Canvas clicked, redirecting to parent div click');
                $div.trigger('click');
            });
        });
        
        console.log(`Click events enabled for ${$('.sigma-query-result-board').length} query results`);
    }

   
    function copyGraphToConstructor(result) {
        console.log('copyGraphToConstructor called with result:', result);
        
        isCopyingRecommendedPattern = true;
        
        usedRecommendedPattern = true;
        console.log('Marked as using recommended pattern, will count when query is executed');
        
        let currentQueryNodes = new Set();
        
        if (window.sigma_constructor && window.sigma_constructor.graph) {
            const constructorNodes = window.sigma_constructor.graph.nodes();
            constructorNodes.forEach(node => {
                currentQueryNodes.add(node.id);
            });
            console.log(`From constructor: ${constructorNodes.length} query nodes`);
        } else {
           
            const originalQuery = getOriginalQueryNodes();
           
            if (originalQuery.nodes) {
                if (originalQuery.nodes instanceof Set) {
                    currentQueryNodes = originalQuery.nodes;
                } else {
                   
                    Object.keys(originalQuery.nodes).forEach(nodeId => {
                        currentQueryNodes.add(nodeId);
                    });
                }
                console.log(`Using saved query snapshot: ${currentQueryNodes.size} nodes`);
            }
        }
        
        try {
           
            clearGraphOnly(s);
            console.log('Graph cleared successfully');
            
           
            s.camera.goTo({x: 0, y: 0, ratio: 1});
            
           
            const nodeIdMap = {};
            
           
            let finalCoordinates = null;
            const clickedDiv = $('.sigma-query-result-board').filter(function() {
                return $(this).data('resultData') === result;
            });
            
            if (clickedDiv.length > 0) {
                const sigmaInstance = clickedDiv.data('sigmaObject');
                if (sigmaInstance && sigmaInstance.graph) {
                    const sigmaNodes = sigmaInstance.graph.nodes();
                    if (sigmaNodes.length === result.nodes.length) {
                        finalCoordinates = {};
                        sigmaNodes.forEach(node => {
                           
                            if (currentQueryNodes.has(node.id)) {
                               
                                finalCoordinates[node.id] = {
                                    x: node.x / 0.6,
                                    y: node.y / 0.6
                                };
                                console.log(`Restoring query node ${node.id}: result(${node.x.toFixed(1)}, ${node.y.toFixed(1)}) -> constructor(${finalCoordinates[node.id].x.toFixed(1)}, ${finalCoordinates[node.id].y.toFixed(1)})`);
                            } else {
                               
                                finalCoordinates[node.id] = {
                                    x: node.x / 0.6,
                                    y: node.y / 0.6
                                };
                                console.log(`Restoring new node ${node.id}: result(${node.x.toFixed(1)}, ${node.y.toFixed(1)}) -> constructor(${finalCoordinates[node.id].x.toFixed(1)}, ${finalCoordinates[node.id].y.toFixed(1)})`);
                            }
                        });
                        console.log('Extracted and scaled coordinates from sigma instance:', finalCoordinates);
                    }
                }
            }
            
           
            result.nodes.forEach((node, i) => {
                const numericLabel = node.label.toString();
                const atomicLabel = getCurrentReverseAtomicLabels()[numericLabel] || numericLabel;
                
                console.log(`Adding node ${i}: label=${numericLabel} -> ${atomicLabel}`);
                
                let x, y;
                if (finalCoordinates && finalCoordinates[node.id]) {
                   
                    x = finalCoordinates[node.id].x;
                    y = finalCoordinates[node.id].y;
                    console.log(`Using sigma coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})`);
                } else {
                   
                    const nodeCount = result.nodes.length;
                    const gridSize = Math.ceil(Math.sqrt(nodeCount));
                    const spacing = 60;
                    const gridX = (i % gridSize) - (gridSize - 1) / 2;
                    const gridY = Math.floor(i / gridSize) - Math.floor((nodeCount - 1) / gridSize) / 2;
                    x = gridX * spacing;
                    y = gridY * spacing;
                    console.log(`Using grid coordinates: (${x}, ${y})`);
                }
                
               
                const success = addNode(s, x, y, true, atomicLabel);
                
                if (success) {
                    nodeIdMap[node.id] = s.nodeCnt - 1;
                    console.log(`Node ${node.id} mapped to ${s.nodeCnt - 1}`);
                } else {
                    console.error(`Failed to add node ${node.id}`);
                }
            });
            
            console.log('Node ID mapping:', nodeIdMap);
            
           
            result.edges.forEach((edge, i) => {
                const sourceId = nodeIdMap[edge.source];
                const targetId = nodeIdMap[edge.target];
                const edgeType = edge.type || 0;
                
                console.log(`Adding edge ${i}: ${edge.source}(${sourceId}) -> ${edge.target}(${targetId}) type=${edgeType}`);
                
                if (sourceId !== undefined && targetId !== undefined) {
                    const success = addEdge(s, sourceId, targetId, edgeType);
                    if (!success) {
                        console.error(`Failed to add edge ${edge.source} -> ${edge.target}`);
                    }
                } else {
                    console.error(`Missing node mapping for edge ${edge.source} -> ${edge.target}`);
                }
            });
            
            console.log('All nodes and edges added');
            
           
            result.nodes.forEach(node => {
                if (currentQueryNodes.has(node.id)) {
                    const sigmaNode = s.graph.nodes(nodeIdMap[node.id]);
                    if (sigmaNode) {
                        sigmaNode.isOriginalQuery = true;
                        sigmaNode.isFixedPosition = true;
                        console.log(`Marked copied node ${node.id} as query node (including manually added)`);
                    }
                } else {
                    const sigmaNode = s.graph.nodes(nodeIdMap[node.id]);
                    if (sigmaNode) {
                        sigmaNode.isNewNode = true;
                        console.log(`Marked copied node ${node.id} as TED-expanded node`);
                    }
                }
            });
            
           
            function moveGraphToCenter() {
                const nodes = s.graph.nodes();
                console.log(`=== CENTERING ${nodes.length} NODES ===`);
                
                if (nodes.length > 0) {
                   
                    let sumX = 0, sumY = 0;
                    nodes.forEach(node => {
                        sumX += node.x;
                        sumY += node.y;
                    });
                    const currentCenterX = sumX / nodes.length;
                    const currentCenterY = sumY / nodes.length;
                    
                   
                    const offsetX = 0 - currentCenterX;
                    const offsetY = 0 - currentCenterY;
                    
                    console.log(`Current graph center: (${currentCenterX.toFixed(2)}, ${currentCenterY.toFixed(2)})`);
                    console.log(`Moving to origin (0, 0), offset: (${offsetX.toFixed(2)}, ${offsetY.toFixed(2)})`);
                    
                   
                    nodes.forEach((node, i) => {
                        node.x += offsetX;
                        node.y += offsetY;
                    });
                    
                   
                    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                    nodes.forEach(node => {
                        minX = Math.min(minX, node.x);
                        maxX = Math.max(maxX, node.x);
                        minY = Math.min(minY, node.y);
                        maxY = Math.max(maxY, node.y);
                    });
                    
                    const currentWidth = maxX - minX;
                    const currentHeight = maxY - minY;
                    const currentSize = Math.max(currentWidth, currentHeight);
                    
                    console.log(`Graph size: ${currentWidth.toFixed(2)} x ${currentHeight.toFixed(2)}`);
                    
                   
                    if (currentSize > 0) {
                        let targetSize;
                        const nodeCount = nodes.length;
                        
                        if (nodeCount > 20) {
                           
                            if (currentSize < 200) {
                                targetSize = 350;
                            } else if (currentSize > 600) {
                                targetSize = 500;
                            } else {
                                targetSize = currentSize * 1.1;
                            }
                            console.log(`🎯 Large graph (${nodeCount} nodes), target size: ${targetSize}`);
                        } else if (nodeCount > 11) {
                           
                        if (currentSize < 150) {
                                targetSize = 280;
                            } else if (currentSize > 500) {
                                targetSize = 430;
                            } else {
                                targetSize = currentSize * 1.2;
                            }
                            console.log(`🎯 Medium-large graph (${nodeCount} nodes), target size: ${targetSize}`);
                        } else {
                           
                            if (currentSize < 150) {
                                targetSize = 300;
                        } else if (currentSize < 250) {
                            targetSize = 400;
                        } else if (currentSize > 500) {
                            targetSize = 450;
                        } else {
                            targetSize = currentSize * 1.3;
                            }
                            console.log(`🎯 Small graph (${nodeCount} nodes), target size: ${targetSize}`);
                        }
                        
                        if (Math.abs(targetSize - currentSize) > 15) {
                            const scaleFactor = targetSize / currentSize;
                            console.log(`Scaling by factor: ${scaleFactor.toFixed(2)}`);
                            
                           
                            nodes.forEach(node => {
                                node.x *= scaleFactor;
                                node.y *= scaleFactor;
                            });
                            
                            console.log(`Graph scaled to size: ${(currentSize * scaleFactor).toFixed(2)}`);
                        }
                    }
                    
                   
                    s.camera.goTo({x: 0, y: 0, ratio: 1});
                    s.refresh();
                debouncedSaveQueryGraph();
                    console.log('Graph positioned and scaled properly');
                }
            }
            
           
            if (finalCoordinates) {
               
                setTimeout(() => {
                    moveGraphToCenter();
                    console.log('Graph copied with extracted sigma coordinates');
                    
                   
                    setTimeout(() => {
                        console.log('🌟 Automatically starting free layout optimization...');
                        applyFreeLayout(s, 1200);
                        stepCounter.inc('Automatic free layout optimization', `Automatically applied free layout optimization to ${s.graph.nodes().length} nodes after copying query result`);
                    }, 100);
                }, 50);
            } else {
               
                console.log('No coordinates extracted, using layout');
                s.startForceAtlas2();
                setTimeout(() => {
                    s.stopForceAtlas2();
                    moveGraphToCenter();
                    console.log('Graph copied with generated layout');
                    
                   
                    setTimeout(() => {
                        console.log('🌟 Automatically starting free layout optimization...');
                        applyFreeLayout(s, 1200);
                        stepCounter.inc('Automatic free layout optimization', `Automatically applied free layout optimization to ${s.graph.nodes().length} nodes after copying query result`);
                    }, 100);
                }, 500);
            }
            
           
            $('#query-result').hide();
            $('#query-constructor').show();
            console.log('View switched to constructor');
            
           
            updateNodeCounter();
            
        } catch (error) {
            console.error('Error in copyGraphToConstructor:', error);
            alert('Failed to copy graph to constructor. Check console for details.');
        } finally {
           
            isCopyingRecommendedPattern = false;
            console.log('Copying recommended pattern protection cleared');
        }
    }

    function generateBigGraphPanel(pattern) {
        $('#query-result').show();

        sd.camera.goTo({x: 0, y: 0});
        sd.nodeCnt = 0;
        sd.edgeCnt = 0;
        sd.graph.clear();
        sd.refresh();
        drawGeneratedPattern(sd, pattern);
       
        console.log(pattern)
       
       
    }

    
    function generateGeneratedPatternsPanel(organizeWay) {
       
        $('#pageloader').fadeIn();

        let data = [];
        switch (organizeWay) {
            case 'group-by-size':
                console.log(displayPatterns)
                displayPatterns.forEach(pattern => {
                    let i = data.findIndex(a => a.size >= pattern.e.length);
                    if (-1 != i && data[i].size == pattern.e.length) {
                        data[i].patterns.push(pattern);
                        data[i].name = 'S' + pattern.e.length + '(' + data[i].patterns.length + ')';
                    } else {
                        data.splice(-1 == i ? data.length : i, 0, {
                            size: pattern.e.length,
                            name: 'S' + pattern.e.length + '(1)',
                            patterns: [pattern]
                        });
                    }
                });
                console.log(data)
                break;
            case 'single-page':
                data.push({
                    name: 'All(' + displayPatterns.length + ')',
                    patterns: displayPatterns
                });
                break;
            default:
                let x = parseInt(organizeWay);
                let pn = 1, pc = 0;
                displayPatterns.forEach(pattern => {
                    if (pc == 0) {
                        data.push({
                            name: 'P' + pn + '(1)',
                            patterns: [pattern]
                        });
                        ++pc;
                    } else {
                        data[pn - 1].patterns.push(pattern);
                        data[pn - 1].name = 'P' + pn + '(' + (++pc) + ')';
                        if (pc == x) {
                            ++pn;
                            pc = 0;
                        }
                    }
                });
        }

        generatedPatternSigmaObjects.forEach(s => s.kill());
        generatedPatternsTab.siblings().show();
        generatedPatternsTab.empty();
        generatedPatternsContent.empty();
        generatedPatternSigmaObjects = [];
        generatedPatternSigmaObjectsByTab = {};

        let containerDefaultWeight = 0, containerDefaultHeight = 0;
        data.forEach((elm, i) => {
            let li = $('<li>', {
                class: 'nav-item'
            });
            let a = $('<a>', {
                class: 'nav-link' + (i == 0 ? ' show active' : ''),
                'data-toggle': 'pill',
                href: '#tab' + i,
                role: 'tab',
                text: elm.name
            });
            a.appendTo(li);
            li.appendTo(generatedPatternsTab);

            let tabPane = $('<div>', {
                class: 'tab-pane fade' + (i == 0 ? ' show active' : ''),
                id: 'tab' + i,
                role: 'tabpanel'
            });
            tabPane.appendTo(generatedPatternsContent);
            let row = $('<div>', {
                class: 'row'
            });
            row.appendTo(tabPane);

            generatedPatternSigmaObjectsByTab['#tab' + i] = [];
            elm.patterns.forEach(pattern => {
                let col = $('<div>', {
                    class: 'col-3 px-1 py-1'
                });
                let div = $('<div>', {
                    class: 'sigma-generated-pattern-container mb-1'
                });

                col.appendTo(row);
                div.appendTo(col);
                let s = new sigma({
                    renderers: [
                        {
                            container: div.get(0),
                            type: 'canvas'
                        }
                    ],
                    settings: patternSigmaSettings
                });
                s.nodeCnt = 0;
                s.edgeCnt = 0;
                s.nodeSize = PATTERN_NODE_SIZE;
                s.edgeSize = PATTERN_EDGE_SIZE;
                s.patternId = `[Generated] ${pattern.id}`;
                if (i == 0 && s.renderers[0].container.offsetWidth && s.renderers[0].container.offsetHeight) {
                    containerDefaultWeight = s.renderers[0].container.offsetWidth;
                    containerDefaultHeight = s.renderers[0].container.offsetHeight;
                }
                s.containerDefaultWeight = containerDefaultWeight;
                s.containerDefaultHeight = containerDefaultHeight;
                drawGeneratedPattern(s, pattern);
                div.data('sigmaObject', s);
                generatedPatternSigmaObjects.push(s);
                generatedPatternSigmaObjectsByTab['#tab' + i].push(s);
            });
        });

        $('a[data-toggle="pill"]').on('shown.bs.tab', function (e) {
            generatedPatternSigmaObjectsByTab[$(e.currentTarget).attr('href')].forEach(p => {
                rotateTofitContainer(p);
                scaleTofitContainer(p);
                enableDrag('sigma-generated-pattern-container', s);
            });
        });
        enableDoubleClick('sigma-generated-pattern-container', s)
        enableDrag('sigma-generated-pattern-container', s);

       
        setTimeout(() => $('#pageloader').fadeOut(), LAYOUT_RUN_TIME * 2);
    }

    $(document).ready(function () {
        console.log('Document ready event fired');
        
       
        $('[data-toggle="tooltip"]').tooltip();

       
        console.log('About to initialize global button click counter');
        initializeGlobalButtonClickCounter();

       
        setTimeout(() => {
            console.log('Checking button styles...');
            $('.modern-btn').each(function(index) {
                const $btn = $(this);
                const btnRect = this.getBoundingClientRect();
                const icon = $btn.find('i');
                
                console.log(`Button ${index}:`, {
                    element: this,
                    text: $btn.text().trim(),
                    html: $btn.html(),
                    class: $btn.attr('class'),
                    id: $btn.attr('id'),
                    visible: $btn.is(':visible'),
                    icon_class: icon.attr('class'),
                    icon_computed_content: window.getComputedStyle(icon[0], '::before').content,
                    dimensions: {
                        width: btnRect.width,
                        height: btnRect.height,
                        top: btnRect.top,
                        left: btnRect.left
                    },
                    computed_styles: {
                        display: $btn.css('display'),
                        visibility: $btn.css('visibility'),
                        color: $btn.css('color'),
                        background: $btn.css('background'),
                        background_color: $btn.css('background-color'),
                        font_size: $btn.css('font-size'),
                        font_family: $btn.css('font-family'),
                        font_weight: $btn.css('font-weight'),
                        padding: $btn.css('padding'),
                        border: $btn.css('border'),
                        opacity: $btn.css('opacity'),
                        text_shadow: $btn.css('text-shadow'),
                        white_space: $btn.css('white-space')
                    }
                });
            });
            
           
            console.log('Checking FontAwesome status...');
            const testIcon = $('<i class="fa fa-test" style="position:absolute;left:-9999px;"></i>').appendTo('body');
            const iconWidth = testIcon.width();
            testIcon.remove();
            const fontAwesomeLoaded = iconWidth > 0;
            console.log('FontAwesome loaded:', fontAwesomeLoaded ? 'YES' : 'NO');
            
           
            if (!fontAwesomeLoaded) {
                console.log('Applying FontAwesome fallback...');
                
               
                $('.modern-btn i.fa').each(function() {
                    const $icon = $(this);
                    const $btn = $icon.closest('.modern-btn');
                    
                   
                    if ($icon.hasClass('fa-file-text')) {
                        $icon.replaceWith('. ');
        } else {
                        $icon.remove();
                    }
                    
                   
                    $btn.css({
                        'display': 'inline-block',
                        'visibility': 'visible',
                        'color': 'white',
                        'background': $btn.hasClass('modern-btn-primary') ? 
                            'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : 
                            'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)'
                    });
                });
                
                console.log('FontAwesome fallback applied');
            }
            
           
            console.log('Checking all buttons...');
            $('button').each(function(index) {
                const $btn = $(this);
                if (index < 5) {
                    console.log(`All Button ${index}:`, {
                        text: $btn.text().substring(0, 20),
                        class: $btn.attr('class'),
                        visible: $btn.is(':visible')
                    });
                }
            });
        }, 1500);

       
        let checkTimer = () => {
            if (timerEnabled) {
                let sec = parseInt((new Date().getTime() - timer) / 1000);
                let min = parseInt(sec / 60);
                sec %= 60;
                let timeStr = ('00' + min).slice(-2) + ':' + ('00' + sec).slice(-2);
                $('#timer span').text(timeStr);
                $('.modern-stats #timer').text(timeStr);
            }
        }
        setInterval(checkTimer, 500);
        
       
        let updateCounters = () => {
            let stepCount = $('#step-count span').text().replace(/\D/g, '');
            let patternCount = $('#pattern-count span').text().replace(/\D/g, '');
            $('.modern-stats #step-count').text(stepCount);
            $('.modern-stats #pattern-count').text(patternCount);
        }
        
       
        let originalStepInc = stepCounter.inc;
        stepCounter.inc = function(name) {
            originalStepInc.call(this, name);
            updateCounters();
        };
        
        let originalPatternInc = patternCounter.inc;
        patternCounter.inc = function(name) {
            originalPatternInc.call(this, name);
            updateCounters();
        };

        $('#timer').click(() => {
            if ($('#timer i').hasClass('fa-play')) {
                timerEnabled = true;
                timer = new Date().getTime();
                $('#timer i').removeClass('fa-play').addClass('fa-circle');
                reset(s);
            } else if ($('#timer i').hasClass('fa-circle')) {
                timerEnabled = false;
                $('#timer i').removeClass('fa-circle').addClass('fa-stop');
                
               
                const currentStats = {
                    timestamp: new Date().toISOString(),
                    timer: $('#timer span').text(),
                    steps: $('#step-count span').text().replace(/\D/g, ''),
                    patterns: $('#pattern-count span').text().replace(/\D/g, ''),
                    queryResults: queryResults.length,
                    vf2Time: window.currentVf2Time || null,
                    totalTime: window.currentTotalTime || null
                };
                queryStats.push(currentStats);
            } else if ($('#timer i').hasClass('fa-stop')) {
                timerEnabled = false;
                $('#timer i').removeClass('fa-stop').addClass('fa-play');
                $('#timer span').text('00:00');
                
               
                if (window.currentQueryId && queryStats.length > 0) {
                    $.ajax({
                        url: '/save_query_stats',
                        method: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify({
                            queryId: window.currentQueryId,
                            stats: queryStats
                        }),
                        success: function(response) {
                            if (!response.success) {
                                console.error('Failed to save query statistics:', response.message);
                            }
                        },
                        error: function(xhr, status, error) {
                            console.error('Error saving query statistics:', error);
                        }
                    });
                }
                
               
                queryStats = [];
                window.currentVf2Time = null;
                window.currentTotalTime = null;
            }
        });

       
        $('#labels-panel').css('max-width', ($('.container-fluid').width() - parseInt($('#board').css('min-width')) - $('#patterns-panel').width() - 25) + 'px');
        $('#resize-gap').draggable({
            helper: 'clone',
            cursor: 'col-resize',
            drag: e => {
                let newWidth = Math.max(220, Math.min(350, e.originalEvent.originalEvent.clientX));
                $('#labels-panel').css('width', newWidth + 'px');
                s.refresh();
                debouncedSaveQueryGraph();
            }
        });

       
        $('#labels-search-box').keyup(() => {
            let keyword = $('#labels-search-box').val();
            if (keyword) {
                let n = 0;
                $.each($('#plain-labels .list-group-item'), (_, l) => {
                    if ($(l).text().toUpperCase().includes(keyword.toUpperCase())) {
                        ++n;
                        $(l).show();
                    } else
                        $(l).hide();
                });
                $('#plain-labels').show();
                $('#nested-labels').hide();
                $('#labels-panel .card-footer').text(0 == n ? 'no result' : 1 == n ? '1 result' : n + ' results');
                } else {
                $('#nested-labels').show();
                $('#plain-labels').hide();
                let n = $('#nested-labels .list-group-item-action').length;
                $('#labels-panel .card-footer').text(0 == n ? 'no label' : 1 == n ? '1 label' : n + ' labels');
            }
        });

       
        $('#generated-patterns-organize-way').change(() => {
            console.log(`modify organize way of generated patterns to ${$('#generated-patterns-organize-way').val()}`);
            generateGeneratedPatternsPanel($('#generated-patterns-organize-way').val());
        });
        $('.nav>div').click((e) => {
           
           
           
            if (e.target.innerText === 'Query constructor') {
                $('#query-constructor').show();
                $('#query-result').hide();
                s.refresh()
               
            } else if (e.target.innerText === 'Query result') {
                $('#query-result').show();
                sd.camera.goTo({x: 0, y: 0});
            }
        })

        s = new sigma({
            renderer: {
                container: 'board',
                type: 'canvas'
            },
            settings: boardSigmaSettings
        });
        
       
        window.sigma_constructor = s;
        
       
        updateNodeCounter();

        sd = new sigma({
            renderers: [
                {
                    container: "board-res",
                    type: 'canvas'
                }
            ],
            settings: boardResSigmaSettings
        });

        s.nodeCnt = 0;
        s.edgeCnt = 0;
        s.nodeSize = NODE_SIZE;
        s.edgeSize = EDGE_SIZE;
        s.minNodeDistance = MIN_NODE_DISTANCE;
        s.sigmaMouse = document.querySelector('#board canvas.sigma-mouse');

       
        s.activeState = sigma.plugins.activeState(s);
        sd.activeState = sigma.plugins.activeState(sd);
       
        s.dragListener = sigma.plugins.dragNodes(s, s.renderers[0], s.activeState);
       
        s.select = sigma.plugins.select(s, s.activeState);
       
        s.lasso = sigma.plugins.lasso(s, s.renderers[0], {
            'strokeStyle': 'rgb(236, 81, 72)',
            'lineWidth': 2,
            'fillWhileDrawing': true,
            'fillStyle': 'rgba(236, 81, 72, 0.2)',
            'cursor': 'crosshair'
        });
        s.select.bindLasso(s.lasso);

       
        s.dragListener.bind('startdrag', function (e) {
            console.log('dragNodes startdrag', e);
            draggingNodes = {};
            draggingNodes[e.data.node.id] = [e.data.node.x, e.data.node.y];
            if (1 == s.activeState.nbNodes()) {
                beforeDragNodeId = s.activeState.nodes()[0].id;
            } else {
                beforeDragNodeId = undefined;
                if (inActiveState(s, e.data.node.id) && s.activeState.nbNodes() > 1) {
                    draggingNodes = {};
                    dragDx = [];
                    dragDy = [];
                    s.activeState.nodes().forEach(n => {
                        draggingNodes[n.id] = [n.x, n.y];
                        dragDx.push(n.x - e.data.node.x);
                        dragDy.push(n.y - e.data.node.y);
                    });
                }
            }
        });
        s.dragListener.bind('drag', function (e) {
           
            beforeDragNodeId = undefined;
            if (inActiveState(s, e.data.node.id) && s.activeState.nbNodes() > 1) {
                s.activeState.nodes().forEach((n, i) => {
                    n.x = dragDx[i] + e.data.node.x;
                    n.y = dragDy[i] + e.data.node.y;
                });
                s.refresh();
                debouncedSaveQueryGraph();
            }
        });
        s.dragListener.bind('drop', function (e) {
           
            beforeDragNodeId = undefined;
        });
        s.dragListener.bind('dragend', function (e) {
            console.log('dragNodes dragend', e);
            if (undefined != beforeDragNodeId) {
               
                let edgeType = 0;
                
                if (e.data.captor.shiftKey && e.data.captor.ctrlKey) {
                    edgeType = 4;
                } else if (e.data.captor.shiftKey && e.data.captor.altKey) {
                    edgeType = 5;
                } else if (e.data.captor.shiftKey) {
                    edgeType = 1;
                } else if (e.data.captor.ctrlKey) {
                    edgeType = 2;
                } else if (e.data.captor.altKey) {
                    edgeType = 3;
                }
                
                if (addEdge(s, beforeDragNodeId, e.data.node.id, edgeType)) {
                    stepCounter.inc('Manual edge creation', `Created edge of type ${edgeType} between nodes ${beforeDragNodeId} and ${e.data.node.id}`);
                    
                   
                    if (usedRecommendedPattern && !isCopyingRecommendedPattern) {
                        console.log('Manual edge addition detected, resetting recommended pattern flag');
                        usedRecommendedPattern = false;
                    }
                    
                    setTimeout(() => {
                        s.activeState.dropNodes();
                        s.refresh();
                debouncedSaveQueryGraph();
                    }, 0);
                }
            } else
                mergeNodes(s);
        });

       
        s.sigmaMouse.addEventListener('mousedown', function (e) {
            console.log('sigmaMouse mousedown', e);
           
            mouseMoved = false;
        }, false);
        s.sigmaMouse.addEventListener('mousemove', function (e) {
           
            mouseMoved = true;
        }, false);
        s.sigmaMouse.addEventListener('mouseup', function (e) {
            console.log('sigmaMouse mouseup', e);
            lastTimeClickOnBoard = new Date();
            if (mouseMoved)
                return;
           
            if (2 == e.button) {
                $('#board .sigma-mouse').hide();
                setTimeout(() => {
                    $('#board .sigma-mouse').show();
                }, 50);
            }
            if (0 != e.button)
                return;
            if (s.activeState.nbNodes()) {
                s.activeState.dropNodes();
                s.refresh();
                debouncedSaveQueryGraph();
                return;
            }
            let x = sigma.utils.getX(e) - s.sigmaMouse.offsetWidth / 2;
            let y = sigma.utils.getY(e) - s.sigmaMouse.offsetHeight / 2;
            let p = s.camera.cameraPosition(x, y);
            
           
            let labelToUse = currentSelectedLabel || '';
            if (addNode(s, p.x, p.y, false, labelToUse)) {
                stepCounter.inc('Manual node creation', `Created node with label "${labelToUse}" at coordinates (${Math.round(p.x)}, ${Math.round(p.y)})`);
                
               
                if (usedRecommendedPattern && !isCopyingRecommendedPattern) {
                    console.log('Manual node addition detected, resetting recommended pattern flag');
                    usedRecommendedPattern = false;
                }
            }
           
            s.activeState.dropNodes();
            s.activeState.addNodes(s.graph.nodes().slice(-1).pop());
            s.refresh();
                debouncedSaveQueryGraph();
        }, false);

       
        $('#board').parent().on('contextmenu', (e) => {
            console.log('board contextmenu', e);
            e.preventDefault();
        }, false);
        s.renderers[0].bind('rightClickNode', function (e) {
            console.log('rightClickNode', e);
            console.log('remove node ' + e.data.node.id);
            let removedNodeCount = 1;
            let removedNodeIds = [];
            
            if (inActiveState(s, e.data.node.id)) {
                removedNodeCount = s.activeState.nodes().length;
                removedNodeIds = s.activeState.nodes().map(n => n.id);
                s.activeState.nodes().forEach(n => s.graph.dropNode(n.id));
            } else {
                removedNodeIds = [e.data.node.id];
                s.graph.dropNode(e.data.node.id);
            }
            
           
            for (let i = 0; i < removedNodeCount; i++) {
                stepCounter.inc('Node deletion', `Deleted node ${removedNodeIds[i] || 'unknown'} (${i + 1}/${removedNodeCount})`);
            }
            
           
            if (usedRecommendedPattern && !isCopyingRecommendedPattern) {
                console.log('Manual node deletion detected, resetting recommended pattern flag');
                usedRecommendedPattern = false;
            }
            
            s.refresh();
                debouncedSaveQueryGraph();
            
           
            if (s === window.sigma_constructor) {
                updateNodeCounter();
            }
            
           
            $('#board .sigma-mouse').hide();
            setTimeout(() => {
                $('#board .sigma-mouse').show();
            }, 50);
        });

       
        s.renderers[0].bind('rightClickEdge', function (e) {
            console.log('rightClickEdge', e);
            console.log('remove edge ' + e.data.edge.id);
            const edgeInfo = `edge ${e.data.edge.id}(${e.data.edge.source}-${e.data.edge.target})`;
            s.graph.dropEdge(e.data.edge.id);
            stepCounter.inc('Edge deletion', `Deleted ${edgeInfo}`);
            
           
            if (usedRecommendedPattern && !isCopyingRecommendedPattern) {
                console.log('Manual edge deletion detected, resetting recommended pattern flag');
                usedRecommendedPattern = false;
            }
            s.refresh();
                debouncedSaveQueryGraph();
           
            $('#board .sigma-mouse').hide();
            setTimeout(() => {
                $('#board .sigma-mouse').show();
            }, 50);
        });

       
        s.renderers[0].bind('render', function (e) {
            console.log('render');
            s.renderers[0].halo({
                nodes: s.activeState.nodes()
            });
        });
        s.lasso.bind('selectedNodes', function (e) {
            s.activeState.dropNodes();
            s.activeState.addNodes(e.data.map(function (n) {
                return n.id;
            }));
            setTimeout(function () {
               
                s.lasso.deactivate();
               
                s.refresh({skipIdexation: true});
            }, 0);
        });

       

       
        $('#upload-datastore-modal').on('show.bs.modal', () => {
            $('#upload-datastore-modal form')[0].reset();
            $('#upload-file').siblings('label').text('Choose file...');
        });
        $('#upload-file').change(() => {
            $('#upload-file').siblings('label').text($('#upload-file').val() ? $('#upload-file').val().split('\\').pop() : 'Choose file...');
        });
        $('#upload-datastore-modal form').submit(() => {
            console.log('upload-datastore-modal form submit');
            let data = new FormData();
            let name = $('#upload-datastore-name').val();
            data.append('name', name);
            data.append('file', $('#upload-file')[0].files[0]);
            $.ajax({
                type: 'POST',
                url: '/datastores',
                data: data,
                processData: false,
                contentType: false,
                dataType: 'json',
                beforeSend: () => {
                    $('#pageloader').fadeIn();
                },
                success: (res) => {
                    if (res.success) {
                        alert('Datastore \'' + name + '\' successfully uploaded!');
                        $('#upload-datastore-modal').modal('hide');
                    } else {
                        alert('Error message:\n' + res.message);
                    }
                },
                complete: () => {
                    $('#pageloader').fadeOut();
                }
            });
            return false;
        });

       
        $('#load-datastore-modal').on('show.bs.modal', () => {
            $('#load-datastore-name').empty();
            $('#datastore-pending-list').empty();
            $('#pageloader').fadeIn();
            $.get('/datastores', (data) => {
                data.forEach(d => {
                    switch (d.status) {
                        case 'Ready':
                            $('#load-datastore-name').append($('<option>').attr('value', d.name).text(d.name));
                            break;
                        case 'Pending':
                            $('#datastore-pending-list').append($('<li>').html(d.name + '&nbsp;&nbsp;').append($('<span>', {class: 'badge badge-warning'}).text(d.status)));
                            break;
                        default:
                            if (d.status.startsWith('Failed'))
                                $('#datastore-pending-list').append($('<li>').html(d.name + '&nbsp;&nbsp;').append($('<span>', {class: 'badge badge-danger'}).text(d.status)));
                            else
                                $('#datastore-pending-list').append($('<li>').html(d.name + '&nbsp;&nbsp;').append($('<span>', {class: 'badge badge-success'}).text(d.status)));
                    }
                });
                if (0 == $('#datastore-pending-list').children().length)
                    $('#datastore-pending-list').append($('<li>').text('None'));
                $('#pageloader').fadeOut();
            });
        });
        $('#load-datastore-modal form').submit(() => {
            console.log('load-datastore-modal form submit');
            datastoreName = $('#load-datastore-name').val();
           
            generateLabelsPanel(fixedLabels['elements']);
            $.get(`/datastores/${datastoreName}/limits`, (limits) => {
                $('#customized-hub-degree').attr('max', limits.maxDegree);
                $('#customized-ring-length').attr('max', limits.maxCircle);
            });
            $.get(`/datastores/${datastoreName}/infos`, (infos) => {
                $('#current-datastore').removeClass('badge-secondary').addClass('badge-success').text(datastoreName);
                let time = 0;
                for (let i in infos)
                    if (i.startsWith('Time of'))
                        time += infos[i];
                $('#current-datastore-info').attr('data-original-title', `<b>Node number:</b> ${infos['NUM_V'].toLocaleString()}<br>
                    <b>Edge number:</b> ${infos['NUM_E'].toLocaleString()}<br>
                    <b>Time for pattern extraction:</b> ${parseInt(time).toLocaleString()}s`).show();
                alert(`Datastore '${datastoreName}' successfully loaded!`);
                $('#load-datastore-modal').modal('hide');
               
                let blinker = (t) => {
                    if (t > 7) return;
                    if (0 == t % 2)
                        $('#current-datastore-info').fadeOut(500);
                    else
                        $('#current-datastore-info').fadeIn(500);
                    setTimeout(blinker, 510, t + 1);
                };
                blinker(0);
            });
            return false;
        });

       
        $('#generate-patterns-button').click(() => {
            console.log('generate-patterns-button is clicked');
           
           
           
           
           
        });
        $('#generate-patterns-modal').on('show.bs.modal', () => {
            $('#generate-patterns-modal form')[0].reset();
            $('#generate-patterns-labels-type').empty();
            console.log('generate-patterns-modal ON');
            for (let t in fixedLabels)
                $('<option>').attr('value', t).text(t).appendTo($('#generate-patterns-labels-type'));
        });
        $('#generate-patterns-modal form').submit(() => {
            if (displayPatterns.length === 0) {
                alert("Please load graph first!")
                return
            }
            console.log('generate-patterns-modal form submit');
            let num = parseInt($('#generate-patterns-num').val());
            let labelType = $('#fixed-labels-type').val();
            $('#current-datastore').removeClass('badge-secondary').addClass('badge-success').text(labelType);
            generateLabelsPanel(fixedLabels[labelType]);

            $('#pageloader').fadeIn();
            $.ajax({
                type: 'POST',
                url: `/gen_pattern`,
                data: {
                    num: num,
                },
                dataType: 'json',
                timeout: 0
            }).done(res => {
                $('#pageloader').fadeOut();
                $('#generate-patterns-modal').modal('hide');
          
               
            });
            return false;
        });

        $('#start-query-processing').click(function() {
           
            $('#pageloader').fadeIn();
            
           
            $.ajax({
                url: '/check_rerun_status',
                method: 'GET',
                success: function(statusResponse) {
                    console.log("Current isRerun status:", statusResponse.isRerun);
                    
                   
                    let statusMessage = statusResponse.isRerun ? 
                        "Using previously matched graphs (reuse mode)" : 
                        "Searching entire database (full search mode)";
                    
                   
                    saveCurrentQuerySnapshot();
                    console.log('Query snapshot saved before processing:', {
                        nodes: Array.from(currentQuerySnapshot.nodes),
                        edges: Array.from(currentQuerySnapshot.edges)
                    });
                    
                   
                    $.ajax({
                        url: '/query_process',
                        method: 'POST',
                        success: function(response) {
                            console.log("Query processing completed");
                            $('#pageloader').fadeOut();
                            
                            if(response.success) {
                               
                                resetHighlightNodesAndEdges();
                                resetQueryResultPanel();
                                
                               
                                queryResults = response.results;
                                
                               
                                if (response.hasOwnProperty('isRerunSet')) {
                                    let statusMsg = response.isRerunSet ? 
                                        "Next query will only search previously matched graphs (reuse mode)" : 
                                        "Next query will search the entire database (full search mode)";
                                    alert(statusMsg);
                                    console.log("isRerun status set to: " + response.isRerunSet);
                                }
                                
                               
                                console.log("Searching for TED verification and filtering...");
                                verifyTEDResults().then(verificationResult => {
                                    if (verificationResult) {
                                        if (verificationResult.needsReplacement && verificationResult.replacementGraphs) {
                                            console.log("TED verification found issues, using replacement graphs");
                                            queryResults = verificationResult.replacementGraphs;
                                            
                                           
                                            showTEDVerificationMessage(verificationResult.verificationSummary);
        } else {
                                           
                                            console.log("TED verification and filtering completed, using filtered TED results");
                                            
                                           
                                            if (verificationResult.wasFiltered) {
                                               
                                                showTEDVerificationMessage(verificationResult.verificationSummary);
                                            } else if (verificationResult.verificationPassed) {
                                               
                                                console.log("TED verification passed, all graphs meet the criteria");
                                            } else {
                                               
                                                showTEDVerificationMessage(verificationResult.verificationSummary);
                                            }
                                        }
                                    } else {
                                        console.log("TED verification returned empty result, using original query results");
                                }
                                
                               
                                generateQueryResult();
                                }).catch(error => {
                                    console.error("TED verification process error:", error);
                                    console.log("Using original query results");
                                    
                                   
                                    showTEDVerificationMessage("TED verification process error, using original query results");
                                    
                                   
                                    generateQueryResult();
                                });
                                
                               
                                $($('.nav>div').get(0)).removeClass('active');
                                $($('.nav>div').get(1)).addClass('active');
                                $('#query-result').show();
                                
                               
                                if (!$('#toggle-rerun-mode').length) {
                                    let toggleButton = $('<button>')
                                        .attr('id', 'toggle-rerun-mode')
                                        .addClass('btn btn-sm btn-info mt-2')
                                        .text('Toggle Search Mode')
                                        .click(function() {
                                            $.ajax({
                                                url: '/toggle_rerun',
                                                method: 'POST',
                                                success: function(response) {
                                                    alert(response.message);
                                                    console.log('Toggled search mode:', response.isRerun);
                                                },
                                                error: function(error) {
                                                    console.error('Error toggling search mode:', error);
                                                    alert('Failed to toggle search mode');
                                                }
                                            });
                                        });
                                    
                                    $('#query-result').before(toggleButton);
                                }
                                
                            } else {
                                alert("Query processing failed: " + (response.error || "Unknown error"));
                            }
                        },
                        error: function(xhr, status, error) {
                            console.error("Query processing failed:", error);
                            $('#pageloader').fadeOut();
                            alert("Query processing failed. Please try again.");
                        }
                    });
                },
                error: function() {
                    console.error("Failed to get isRerun status");
                    $('#pageloader').fadeOut();
                    alert("Failed to check search mode. Please try again.");
                }
            });
        });
       
        $('#load-local-patterns-modal').on('show.bs.modal', () => {
            $('#load-local-patterns-modal form')[0].reset();
            $('#upload-patterns-file').siblings('label').text('Choose file...');
            $('#fixed-labels-type').empty();
            for (let t in fixedLabels)
                $('<option>').attr('value', t).text(t).appendTo($('#fixed-labels-type'));
        });
        $('#upload-patterns-file').change(() => {
            $('#upload-patterns-file').siblings('label').text($('#upload-patterns-file').val() ? $('#upload-patterns-file').val().split('\\').pop() : 'Choose file...');
        });
        $('#load-local-patterns-modal form').submit(function(e) {
            e.preventDefault();
            
            const selectedDb = $('#database-select').val();
            let dbName = '';
            
           
            switch(selectedDb) {
                case '1':
                    dbName = 'AIDS10K';       
                    break;
                case '2':
                    dbName = 'emolecul';      
                    break;
                case '3':
                    dbName = 'pubchem23238';
                    break;
                default:
                    dbName = 'default';
            }
            
           
            const detectedDataset = detectDatasetType(dbName);
            updateCurrentDataset(detectedDataset);
            
            console.log(`Loading database: ${dbName}, detected dataset: ${detectedDataset}`);
            
            $.ajax({
                url: '/load_graph',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ database: selectedDb }),
                success: function(response) {
                    if (response.success) {
                        $('#load-local-patterns-modal').modal('hide');
                        $('#current-datastore').text(dbName);
                        
                       
                        currentDataset = response.dataset || detectedDataset;
                        console.log(`Frontend dataset updated to: ${currentDataset}`);
                        
                       
                        $.ajax({
                            url: '/get_atomic_labels',
                            method: 'GET',
                            success: function(labelResponse) {
                                if (labelResponse.success) {
                                    console.log('Atomic labels updated:', labelResponse);
                                    
                                   
                                    generateLabelsPanel(labelResponse.orderedLabels);
                                    
                                   
                                    $(document).trigger('datasetChanged', {
                                        dataset: currentDataset,
                                        mapping: labelResponse.atomicLabels
                                    });
                                }
                            },
                            error: function(xhr, status, error) {
                                console.error('Error getting atomic labels:', error);
                            }
                        });
                        
                       
                        console.log('Loading default patterns for database:', dbName);
                        loadDefaultPatterns();
                        
                       
                        autoResetOnDatabaseSwitch();
                        
                       
                        console.log(`已切换到 ${dbName} 数据集，原子标签映射已更新`);
                    } else {
                        alert(response.message || 'Failed to save database selection');
                    }
                },
                error: function(xhr, status, error) {
                    alert('Error saving database selection: ' + error);
                }
            });
        });

       
        $('#customized-hub-modal form').submit(() => {
            console.log('customized-hub-modal form submit');
            let degree = parseInt($('#customized-hub-degree').val());
            drawCustomizedHub(s, addPatternCenter.x, addPatternCenter.y, degree, false);
            scaleTillClear(s, s.activeState.nodes());
            debouncedSaveQueryGraph();

            stepCounter.inc('Add pattern');
            patternCounter.inc('[Default] Customized ego');
            mappingTimeCounter.append((new Date() - lastTimeClickOnBoard) / 1000);
            lastTimeClickOnBoard = new Date();

            $('#customized-hub-modal').modal('hide');
            return false;
        });

        $('#customized-ring-modal form').submit(() => {
            console.log('customized-ring-modal form submit');
            let length = parseInt($('#customized-ring-length').val());
            drawCustomizedRing(s, addPatternCenter.x, addPatternCenter.y, length, false);
            scaleTillClear(s, s.activeState.nodes());
            debouncedSaveQueryGraph();

            stepCounter.inc('Add pattern');
            patternCounter.inc('[Default] Customized ring');
            mappingTimeCounter.append((new Date() - lastTimeClickOnBoard) / 1000);
            lastTimeClickOnBoard = new Date();

            $('#customized-ring-modal').modal('hide');
            return false;
        });

        generateDefaultPatternsPanel();

       
        $(document).keydown(function(e) {
           
            if ((e.keyCode === 46 || e.keyCode === 8) && !$(e.target).is('input, textarea')) {
                e.preventDefault();
                
               
                let selectedNodes = s.activeState.nodes();
                let selectedEdges = s.activeState.edges();
                
               
                selectedEdges.forEach(edge => {
                    s.graph.dropEdge(edge.id);
                });
                
               
                selectedNodes.forEach(node => {
                    s.graph.dropNode(node.id);
                });
                
               
                s.refresh();
                debouncedSaveQueryGraph();
                
               
                debouncedUpdateSnapshot();
                
               
                if (s === window.sigma_constructor) {
                    updateNodeCounter();
                }
            }
        });

       
        $('#new-window-btn').click(function() {
            console.log('New window button clicked via ID!');
            resetButtonHandler();
        });
        
       
        $('button[title="New window"]').click(function() {
            console.log('New window button clicked via title selector!');
            resetButtonHandler();
        });
        
       
        function resetButtonHandler() {
            console.log('User confirmed reset, sending AJAX request...');
           
            $.ajax({
                url: '/reset_rerun',
                method: 'POST',
                data: {},
                contentType: 'application/json',
                success: function(response) {
                    console.log('Reset isRerun flag successful, response:', response);
                },
                error: function(error) {
                    console.error('Error resetting isRerun flag:', error);
                    alert('Failed to reset search mode. Check console for details.');
                }
            });
            
           
            reset(s);
            s.refresh();
                debouncedSaveQueryGraph();
            
           
            debouncedUpdateSnapshot();
            
            console.log('Graph reset complete');
        }

       
        $('#check-status-btn').click(function() {
            console.log('Check status button clicked!');
            
           
            $.ajax({
                url: '/check_rerun_status',
                method: 'GET',
                success: function(response) {
                    console.log('Current search mode:', response.isRerun);
                    alert('Current search mode: ' + 
                          (response.isRerun ? 'Using previous matches' : 'Full database search'));
                },
                error: function(error) {
                    console.error('Error checking search mode:', error);
                    alert('Failed to check search mode. See console for details.');
                }
            });
        });
        
       
        updateEdgeTypesDisplay(currentDataset);
    });

    
   
    let saveQueryGraphTimeout = null;
    let isCurrentlySaving = false;
    let lastSavedGraphHash = null;

    function saveQueryGraph() {
        const graph = s.graph;
        const nodes = graph.nodes();
        const edges = graph.edges();
        
       
        if (nodes.length === 0 && edges.length === 0) {
            console.log('Skipping save: Empty graph');
            return;
        }
        
       
        const atomicToNumber = getCurrentAtomicLabels();
        
        console.log("Original edges:", edges);
        console.log("Current dataset:", currentDataset);
        console.log("Atomic mapping:", atomicToNumber);
        
        const graphData = {
            nodes: nodes.map(node => ({
                id: node.id,
                label: atomicToNumber[node.label] || '0',
                x: node.x,
                y: node.y
            })),
            edges: edges.map(edge => {
                const type = edge.type || 0; 
                console.log(`Edge ${edge.source}-${edge.target} type:`, type);
                return {
                    source: edge.source,
                    target: edge.target,
                    type: type
                };
            })
        };

       
        const graphHash = JSON.stringify(graphData);
        if (graphHash === lastSavedGraphHash) {
            console.log('Skipping save: Graph data unchanged');
            return;
        }

       
        if (isCurrentlySaving) {
            console.log('Skipping save: Currently saving');
            return;
        }

        console.log("Saving graph data:", graphData);
        isCurrentlySaving = true;

        $.ajax({
            url: '/save_graph',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify(graphData),
            success: function(response) {
                isCurrentlySaving = false;
                if (response.success) {
                    lastSavedGraphHash = graphHash;
                    console.log('Query graph saved successfully');
                   
                    debouncedUpdateQueryParameters();
                } else {
                    console.error('Failed to save query graph:', response.message);
                }
            },
            error: function(xhr, status, error) {
                isCurrentlySaving = false;
                console.error('Error saving query graph:', error);
                    }
                });
            }

   
    function debouncedSaveQueryGraph() {
        if (saveQueryGraphTimeout) {
            clearTimeout(saveQueryGraphTimeout);
        }
        saveQueryGraphTimeout = setTimeout(() => {
            saveQueryGraph();
        }, 100);
    }
    
   
    window.manualUpdateParameters = function() {
        console.log('🔧 Manual parameter update triggered');
        updateQueryParametersAfterSave();
    };

   
    
   
    $('#query-params-form').on('submit', function(e) {
        e.preventDefault();
        
        const numberofpatterns = parseInt($('#param-numberofpatterns').val());
        const minnode = parseInt($('#param-minnode').val());
        const maxnode = parseInt($('#param-maxnode').val());
        
       
        if (numberofpatterns < 1 || numberofpatterns > 50) {
            alert('Number of patterns must be between 1 and 50');
            return;
        }
        
        if (minnode < 2 || minnode > 100) {
            alert('Minimum nodes must be between 2 and 100');
            return;
        }
        
        if (maxnode < 2 || maxnode > 100) {
            alert('Maximum nodes must be between 2 and 100');
            return;
        }
        
        if (maxnode < minnode) {
            alert('Maximum nodes must be greater than or equal to minimum nodes');
            return;
        }
        
       
        window.currentQueryId = new Date().getTime().toString();
        
       
        $('#query-params-modal').modal('hide');
        
       
        $('#pageloader').fadeIn();
        
       
        saveCurrentQuerySnapshot();
        
       
        $.ajax({
            url: '/query_process',
            method: 'POST',
            data: {
                numberofpatterns: numberofpatterns,
                minnode: minnode,
                maxnode: maxnode,
                queryId: window.currentQueryId
            },
            success: function(response) {
                $('#pageloader').fadeOut();
                
                if(response.success) {
                   
                    resetHighlightNodesAndEdges();
                    resetQueryResultPanel();
                    
                   
                    queryResults = response.results;
                    
                   
                    if (response.vf2Time !== undefined) {
                        window.currentVf2Time = response.vf2Time;
                    }
                    if (response.totalTime !== undefined) {
                        window.currentTotalTime = response.totalTime;
                    }
                    
                   
                    generateQueryResult();
                    
                    
                } else {
                    alert("Query processing failed: " + (response.error || "Unknown error"));
                }
            },
            error: function(xhr, status, error) {
                $('#pageloader').fadeOut();
                alert("Query processing failed. Please try again.");
            }
        });
    });
    
   
    $('#param-minnode, #param-maxnode').on('change', function() {
        const minnode = parseInt($('#param-minnode').val());
        const maxnode = parseInt($('#param-maxnode').val());
        
        if (maxnode < minnode) {
            $('#param-maxnode').val(minnode);
        }
    });

   
    $('#query-params-modal').on('show.bs.modal', function() {
        console.log('Query Parameters modal is about to show, setting dynamic defaults...');
        setQueryParametersDefaults();
    });

    function generateDefaultPatternsPanel() {
        let defaultPatternsRow = $('#default-patterns-list');
        
       
        defaultPatternsRow.empty();
        
       
        $('.sigma-default-pattern-container').each(function() {
            const sigmaObj = $(this).data('sigmaObject');
            if (sigmaObj && typeof sigmaObj.kill === 'function') {
                sigmaObj.kill();
            }
        });
        
        defaultPatterns.forEach(p => {
            let div = $('<div>', {
                class: 'sigma-default-pattern-container',
                title: p.title
            });
            if ('hub' == p.type)
                div.attr('id', 'customized-hub-default-pattern');
            else if ('ring' == p.type)
                div.attr('id', 'customized-ring-default-pattern');
            div.appendTo(defaultPatternsRow);
            
            let s = new sigma({
                renderers: [{
                    container: div.get(0),
                    type: 'canvas'
                }],
                settings: patternSigmaSettings
            });
            
            s.nodeCnt = 0;
            s.edgeCnt = 0;
            s.nodeSize = PATTERN_NODE_SIZE;
            s.edgeSize = PATTERN_EDGE_SIZE;
            s.patternId = `[Default] ${p.title}`;
            div.data('sigmaObject', s);
            
           
            div.on('click', function(e) {
               
               
            });
        });

       
        $.each($('div.sigma-default-pattern-container'), (i, div) => 
            drawDefaultPattern($(div).data('sigmaObject'), defaultPatterns[i])
        );

       
        enableDrag('sigma-default-pattern-container', s);
        
       
    }
    const datasetAtomicLabels = {
        'AIDS': {
            elements: ["C", "O", "Cu", "N", "S", "P", "Cl", "Zn", "B", "Br", "Co", "Mn", "As", "Al", "Ni", "Se",
                      "Si", "V", "Sn", "I", "F", "Li", "Sb", "Fe", "Pd", "Hg", "Bi", "Na", "Ca", "Ti", "Ho", "Ge",
                      "Pt", "Ru", "Rh", "Cr", "Ga", "K", "Ag", "Au", "Tb", "Ir", "Te", "Mg", "Pb", "W", "Cs", "Mo",
                      "Re", "Cd", "Os", "Pr", "Nd", "Sm", "Gd", "Yb", "Er", "U", "Tl", "Ac"],
            mapping: {}
        },
        'emolecule': {
            elements: ["Cs", "Cu", "Yb", "Cl", "Pt", "Pr", "Co", "Cr", "Li", "Cd", "Ce", "Hg", "Hf", "La", "Lu",
                      "Pd", "Tl", "Tm", "Ho", "Pb", "*", "Ti", "Te", "Dy", "Ta", "Os", "Mg", "Tb", "Au", "Se",
                      "F", "Sc", "Fe", "In", "Si", "B", "C", "As", "Sn", "N", "Ba", "O", "Eu", "H", "Sr", "I", "Mo",
                      "Mn", "K", "Ir", "Er", "Ru", "Ag", "W", "V", "Ni", "P", "S", "Nb",
                      "Y", "Na", "Sb", "Al", "Ge", "Rb", "Re", "Gd", "Ga", "Br", "Rh", "Ca", "Bi", "Zn", "Zr",
                      "R#", "R","X","R1","A","U", "Ar", "Kr", "Xe", "e", ".", "Tc",  "Mu", "Mu-", "He", "Ps", "At",
                      "Po", "Be", "Ne","Rn", "Fr", "Ra", "Ac", "Rf", "Db", "Sg","Bh", "Hs",  "Mt",
                      "Ds", "Rg", "Nd","Pm",  "Sm", "Th", "Pa", "Np","Pu", "Am", "Cm", "Bk",
                      "Cf","Es", "Fm", "Md", "No", "Lr","0", "Uub", "R2", "R3", "R4", "D", "R5", "ACP"],
            mapping: {}
        },
        'pubchem': {
            elements: ["H", "C", "O", "N", "Cl", "S", "F", "P", "Br", "I", "Na", "Si",
                      "As", "Hg", "Ca", "K", "B", "Sn", "Se", "Al", "Fe", "Mg", "Zn", "Pb", "Co", "Cu",
                      "Cr", "Mn", "Sb", "Cd", "Ni", "Be", "Ag", "Li", "Tl", "Sr", "Bi", "Ce", "Ba", "U", "Ge",
                      "Pt", "Te", "V", "Zr", "Cs", "Au", "Mo", "W", "La", "Ti", "Rh", "Lu", "Pd", "In", "Eu", "Ga",
                      "Pr", "Ho", "Th", "Ta", "Tc", "Tb", "Ir", "Nd", "Nb", "Rb", "Kr", "Yb", "Cm", "Pu", "Cf", "Hf",
                      "He", "Pa", "Tm", "Pm", "Po", "Xe", "Dy", "Os", "Md", "Sc", "Ar", "At", "Sm", "Er", "Ru",
                      "Es", "Ac", "Am", "Ne", "Y", "Re", "Gd", "No", "Rn", "Np", "Fm", "Bk", "Lr"],
            mapping: {}
        },
        'default': {
           
            elements: ['C', 'N', 'O', 'H', 'S', 'P', 'F', 'Cl', 'Br', 'I', 'Na', 'Si'],
            mapping: {
                'C': '1',  
                'N': '2',  
                'O': '3',  
                'H': '4',  
                'S': '5',  
                'P': '6',  
                'F': '7',  
                'Cl': '8', 
                'Br': '9', 
                'I': '10', 
                'Na': '11',
                'Si': '12' 
            }
        }
    };
    
   
    Object.keys(datasetAtomicLabels).forEach(dataset => {
        if (dataset !== 'default') {
            const elements = datasetAtomicLabels[dataset].elements;
            elements.forEach((element, index) => {
                datasetAtomicLabels[dataset].mapping[element] = String(index);
            });
        }
    });
    
   
    let currentDataset = 'default';
    
   
    function getCurrentAtomicLabels() {
        return datasetAtomicLabels[currentDataset].mapping;
    }
    
   
    function getCurrentReverseAtomicLabels() {
        const mapping = getCurrentAtomicLabels();
        return Object.fromEntries(
            Object.entries(mapping).map(([k, v]) => [v, k])
        );
    }
    
   
    function detectDatasetType(datastoreName) {
        if (!datastoreName) return 'default';
        
        const name = datastoreName.toLowerCase();
        if (name.includes('aids')) {
            return 'AIDS';
        } else if (name.includes('emolecule') || name.includes('emol') || name.includes('emodulo')) {
            return 'emolecule';
        } else if (name.includes('pubchem')) {
            return 'pubchem';
        }
        return 'default';
    }
    
   
    function updateCurrentDataset(newDataset) {
        if (newDataset !== currentDataset) {
            currentDataset = newDataset;
            console.log(`Switched to dataset: ${currentDataset}`);
            
           
            updateEdgeTypesDisplay(currentDataset);
            
           
            $.ajax({
                url: '/get_atomic_labels',
                method: 'GET',
                success: function(labelResponse) {
                    if (labelResponse.success) {
                       
                        generateLabelsPanel(labelResponse.orderedLabels);
                        
                       
                        $(document).trigger('datasetChanged', {
                            dataset: currentDataset,
                            mapping: labelResponse.atomicLabels
                        });
                    }
                },
                error: function(xhr, status, error) {
                    console.error('Error getting atomic labels:', error);
                }
            });
        }
    }
    
   
    let atomicLabels = getCurrentAtomicLabels();
    let reverseAtomicLabels = getCurrentReverseAtomicLabels();

   
    function updateEdgeTypesDisplay(dataset) {
        const labelsColumn = $('#labels-column');
        const edgeTypesColumn = $('#edge-types-column');
        
        if (dataset === 'AIDS') {
           
            edgeTypesColumn.show();
            labelsColumn.removeClass('col-12').addClass('col-6');
        } else {
           
            edgeTypesColumn.hide();
            labelsColumn.removeClass('col-6').addClass('col-12');
        }
    }

   
    function autoResetOnDatabaseSwitch() {
        console.log('Auto-resetting due to database switch...');
       
        $.ajax({
            url: '/reset_rerun',
            method: 'POST',
            data: {},
            contentType: 'application/json',
            success: function(response) {
                console.log('Auto-reset isRerun flag successful, response:', response);
            },
            error: function(error) {
                console.error('Error auto-resetting isRerun flag:', error);
            }
        });
        
       
        reset(s);
        s.refresh();
                debouncedSaveQueryGraph();
        console.log('Auto-reset complete');
    }

    
    function clearGraphOnly(s) {
        s.camera.goTo({x: 0, y: 0});
        s.nodeCnt = 0;
        s.edgeCnt = 0;
        s.graph.clear();
        s.refresh();
                debouncedSaveQueryGraph();
        
       
        s.activeState.dropNodes();
        
       
        if (s === window.sigma_constructor) {
            updateNodeCounter();
        }
        
       
        lastTimeClickOnBoard = new Date();
        
       
        if (usedRecommendedPattern && !isCopyingRecommendedPattern) {
            console.log('Graph cleared manually, resetting recommended pattern flag');
            usedRecommendedPattern = false;
        }
    }

   
    function initializeGlobalButtonClickCounter() {
        console.log('🔧 [DEBUG] Initializing global button click counter...');
        
       
        $(document).on('click', 'button', function(e) {
           
            const buttonId = $(this).attr('id') || '';
            const buttonText = $(this).text().trim() || '';
            const buttonTitle = $(this).attr('title') || '';
            const buttonClass = $(this).attr('class') || '';
            
            console.log('[DEBUG] Button clicked:', {
                id: buttonId,
                text: buttonText,
                title: buttonTitle,
                class: buttonClass,
                element: this
            });
            
            let shouldCount = true;
            let excludeReason = '';
            
           
            if ($(this).find('.fa-question-circle').length > 0) {
                shouldCount = false;
                excludeReason = 'Help button with question icon';
            } else if ($(this).hasClass('close')) {
                shouldCount = false;
                excludeReason = 'Close button';
            } else if ($(this).attr('data-dismiss') === 'modal') {
                shouldCount = false;
                excludeReason = 'Modal dismiss button';
            } else if (buttonId === 'step-count' || buttonId === 'pattern-count' || buttonId === 'timer') {
                shouldCount = false;
                excludeReason = 'Counter display button';
            } else if ($(this).closest('.modal').length > 0 && 
                      (buttonText.toLowerCase().includes('close') || 
                       buttonText.toLowerCase().includes('cancel'))) {
                shouldCount = false;
                excludeReason = 'Modal cancel/close button';
            }
            
            if (shouldCount) {
                let actionName = buttonText || buttonTitle || buttonId || 'Button Click';
                console.log(' [DEBUG] Step counted for button:', actionName);
                stepCounter.inc(actionName);
                console.log(' [DEBUG] Step counter after increment:', $('#step-count span').text());
            } else {
                console.log(' [DEBUG] Button excluded from counting:', excludeReason);
            }
        });
        
        console.log('🔧 [DEBUG] Global button click counter initialized successfully');
    }

   
    let previousQueryState = null;
    
   
    function saveCurrentQueryState() {
        const graph = s.graph;
        const nodes = graph.nodes();
        const edges = graph.edges();
        
        const state = {
            nodes: nodes.map(node => ({
                id: node.id,
                label: node.label,
                x: node.x,
                y: node.y,
                color: node.color,
                size: node.size
            })),
            edges: edges.map(edge => ({
                id: edge.id,
                source: edge.source,
                target: edge.target,
                type: edge.type,
                color: edge.color,
                size: edge.size
            })),
            camera: {
                x: s.camera.x,
                y: s.camera.y,
                ratio: s.camera.ratio
            },
            parameters: {
                numberofpatterns: parseInt($('#inline-numberofpatterns').val()),
                minnode: parseInt($('#inline-minnode').val()),
                maxnode: parseInt($('#inline-maxnode').val())
            }
        };
        
        console.log('Query state saved:', state);
        return state;
    }
    
   
    function restoreQueryState(state) {
        if (!state) {
            console.warn('No state to restore');
            return;
        }
        
       
        s.graph.clear();
            s.refresh();
        
       
        state.nodes.forEach(nodeData => {
            s.graph.addNode({
                id: nodeData.id,
                label: nodeData.label,
                x: nodeData.x,
                y: nodeData.y,
                color: nodeData.color,
                size: nodeData.size
            });
        });
        
       
        state.edges.forEach(edgeData => {
            s.graph.addEdge({
                id: edgeData.id,
                source: edgeData.source,
                target: edgeData.target,
                type: edgeData.type,
                color: edgeData.color,
                size: edgeData.size || s.edgeSize
            });
        });
        
       
        s.camera.goTo({
            x: state.camera.x,
            y: state.camera.y,
            ratio: state.camera.ratio
        });
        
       
        $('#inline-numberofpatterns').val(state.parameters.numberofpatterns);
        $('#inline-minnode').val(state.parameters.minnode);
        $('#inline-maxnode').val(state.parameters.maxnode);
        
       
        s.refresh();
        
        console.log('Query state restored');
        
       
        $('#undo-query-btn').prop('disabled', true);
        previousQueryState = null;
        
       
        debouncedSaveQueryGraph();
        
       
        updateNodeCounter();
        
       
        setTimeout(() => {
            debouncedUpdateQueryParameters();
        }, 200);
    }
    
   
    $('#undo-query-btn').click(function() {
        if (previousQueryState) {
           
            if (confirm('确定要撤回到查询处理前的状态吗？当前的构造器内容将被替换。')) {
                restoreQueryState(previousQueryState);
                
               
                $('#query-result').hide();
                $('#query-constructor').show();
                
                console.log('Successfully restored to previous query state');
            }
        } else {
            alert('no state to return');
        }
    });
    
   
    $('#optimize-layout-btn').click(function() {
        const nodes = s.graph.nodes();
        
        if (nodes.length === 0) {
            console.log('当前图形中没有节点，跳过布局优化');
            return;
        }
        
        if (nodes.length < 3) {
            console.log('节点数量过少，跳过布局优化');
            return;
        }
        
        $('#optimize-layout-btn').prop('disabled', true).html('<i class="fa fa-spinner fa-spin"></i>');
        
       
        applyFreeLayout(s, 2000);
        
       
        setTimeout(() => {
            $('#optimize-layout-btn').prop('disabled', false).html('<i class="fa fa-magic"></i>');
            console.log('🌟 完全自由布局优化按钮重新启用');
        }, 1500);
        
       
        stepCounter.inc('完全自由布局优化', `对 ${nodes.length} 个节点执行完全自由布局优化`);
    });

   
    $('#direct-query-btn').click(function() {
        console.log('Direct query button clicked');
        
       
        previousQueryState = saveCurrentQueryState();
        $('#undo-query-btn').prop('disabled', false);
        
       
        saveQueryGraph();
        
       
        const numberofpatterns = parseInt($('#inline-numberofpatterns').val());
        const minnode = parseInt($('#inline-minnode').val());
        const maxnode = parseInt($('#inline-maxnode').val());
        
       
        if (numberofpatterns < 1 || numberofpatterns > 50) {
            alert('Number of patterns must be between 1 and 50');
            return;
        }
        
        if (minnode < 2 || minnode > 100) {
            alert('Minimum nodes must be between 2 and 100');
            return;
        }
        
        if (maxnode < 2 || maxnode > 100) {
            alert('Maximum nodes must be between 2 and 100');
            return;
        }
        
        if (maxnode < minnode) {
            alert('Maximum nodes must be greater than or equal to minimum nodes');
            return;
        }
        
       
        window.currentQueryId = new Date().getTime().toString();
        
       
        $('#pageloader').fadeIn();
        
       
        saveCurrentQuerySnapshot();
        
        console.log('Starting query with parameters:', {
            numberofpatterns: numberofpatterns,
            minnode: minnode,
            maxnode: maxnode,
            queryId: window.currentQueryId
        });
        
       
        $.ajax({
            url: '/query_process',
            method: 'POST',
            data: {
                numberofpatterns: numberofpatterns,
                minnode: minnode,
                maxnode: maxnode,
                queryId: window.currentQueryId
            },
            success: function(response) {
                $('#pageloader').fadeOut();
                
                if(response.success) {
                    console.log('Query successful, processing results...');
                    
                   
                    console.log(' Checking usedRecommendedPattern flag:', usedRecommendedPattern);
                    if (usedRecommendedPattern) {
                        patternCounter.inc('Query Result Pattern');
                        console.log('🎯🎯🎯 Pattern counter incremented for using recommended pattern 🎯🎯🎯');
                        usedRecommendedPattern = false;
        } else {
                        console.log('ℹ️ No Query result recommended pattern was used this time');
                       
                    }
                    
                   
                    resetHighlightNodesAndEdges();
                    resetQueryResultPanel();
                    
                   
                    queryResults = response.results;
                    
                   
                    if (response.vf2Time !== undefined) {
                        window.currentVf2Time = response.vf2Time;
                    }
                    if (response.totalTime !== undefined) {
                        window.currentTotalTime = response.totalTime;
                    }
                    
                   
                    generateQueryResult();
                    
                    console.log('Query results displayed successfully');
                    
            } else {
                    console.error('Query failed:', response.error);
                    alert("Query processing failed: " + (response.error || "Unknown error"));
                }
            },
            error: function(xhr, status, error) {
                $('#pageloader').fadeOut();
                console.error('Query request error:', error);
                alert("Query processing failed. Please try again.");
            }
        });
    });
    
   
    $('#inline-minnode, #inline-maxnode').on('change', function() {
        const minnode = parseInt($('#inline-minnode').val());
        const maxnode = parseInt($('#inline-maxnode').val());
        
        if (maxnode < minnode) {
            $('#inline-maxnode').val(minnode);
        }
    });

   

    
    function updateQueryParametersAfterSave() {
        const graph = s.graph;
        const nodes = graph.nodes();
        const edges = graph.edges();
        
        console.log('[updateQueryParametersAfterSave] Starting parameter update check...');
        console.log('[updateQueryParametersAfterSave] Current node count:', nodes.length);
        
       
        if (nodes.length === 0) {
            console.log(' [updateQueryParametersAfterSave] Skipping: No nodes in graph');
            return;
        }
        
       
        const selectedDb = $('#database-select').val();
        const currentNodeCount = nodes.length;
        
        console.log(' [updateQueryParametersAfterSave] Selected database:', selectedDb);
        console.log(' [updateQueryParametersAfterSave] Current node count:', currentNodeCount);
        
       
        const currentMinNode = parseInt($('#inline-minnode').val()) || 8;
        const currentMaxNode = parseInt($('#inline-maxnode').val()) || 10;
        
       
        let shouldUpdate = false;
        let suggestedMinNode, suggestedMaxNode;
        
       
        const suggestedPatterns = 10;
        
        if (selectedDb === '1') {
           
            suggestedMinNode = currentNodeCount + 2;
            suggestedMaxNode = currentNodeCount + 4;
        } else {
           
            suggestedMinNode = currentNodeCount + 3;
            suggestedMaxNode = currentNodeCount + 4;
        }
        
       
        suggestedMinNode = Math.max(2, Math.min(100, suggestedMinNode));
        suggestedMaxNode = Math.max(suggestedMinNode, Math.min(100, suggestedMaxNode));
        
       
        const currentPatterns = parseInt($('#inline-numberofpatterns').val()) || 10;
        if (currentPatterns !== suggestedPatterns || 
            currentMinNode !== suggestedMinNode || 
            currentMaxNode !== suggestedMaxNode) {
            shouldUpdate = true;
        }
        
        console.log(' [updateQueryParametersAfterSave] Current parameters:', {
            patterns: currentPatterns,
            minNode: currentMinNode,
            maxNode: currentMaxNode
        });
        console.log(' [updateQueryParametersAfterSave] Suggested parameters:', {
            patterns: suggestedPatterns,
            minNode: suggestedMinNode,
            maxNode: suggestedMaxNode
        });
        console.log(' [updateQueryParametersAfterSave] Should update:', shouldUpdate);
        
       
        if (shouldUpdate) {
            $('#inline-numberofpatterns').val(suggestedPatterns);
            $('#inline-minnode').val(suggestedMinNode);
            $('#inline-maxnode').val(suggestedMaxNode);
            
            const dbName = selectedDb === '1' ? 'AIDS10K' : (selectedDb === '2' ? 'emolecul' : 'pubchem23238');
            console.log('[updateQueryParametersAfterSave] Parameters updated:', {
                database: dbName,
                currentNodes: currentNodeCount,
                newPatterns: suggestedPatterns,
                newMinNode: suggestedMinNode,
                newMaxNode: suggestedMaxNode
            });
            } else {
            console.log('⏸ [updateQueryParametersAfterSave] No update needed - parameters already correct');
        }
    }

   
    let parameterUpdateTimeout = null;
    
    
    function debouncedUpdateQueryParameters() {
       
        if (parameterUpdateTimeout) {
            clearTimeout(parameterUpdateTimeout);
        }
        
       
        parameterUpdateTimeout = setTimeout(updateQueryParametersAfterSave, 500);
    }

   
    $(document).ready(function() {
       
        $('#label-search-input').on('input', function() {
            const searchTerm = $(this).val().toLowerCase().trim();
            filterLabels(searchTerm);
        });

       
        $('#clear-label-search').on('click', function() {
            $('#label-search-input').val('');
            filterLabels('');
        });

       
        $('#label-search-input').on('keypress', function(e) {
            if (e.which === 13) {
                e.preventDefault();
                const searchTerm = $(this).val().toLowerCase().trim();
                filterLabels(searchTerm);
            }
        });
    });

    
    function filterLabels(searchTerm) {
        const $plainLabels = $('#plain-labels .draggable-label-node');
        const $nestedLabels = $('#nested-labels .list-group-item');
        
       
        hideNoResultsMessage();
        $plainLabels.each(function() {
            const $item = $(this);
           
            const $labelText = $item.find('span').first();
            const originalText = $labelText.attr('data-original-text') || $labelText.text();
            if (!$labelText.attr('data-original-text')) {
                $labelText.attr('data-original-text', originalText);
            }
            $labelText.text(originalText);
        });
        
        if (!searchTerm) {
           
            $plainLabels.show();
            $nestedLabels.show();
            return;
        }

        let hasVisibleResults = false;

       
        $plainLabels.each(function() {
            const $item = $(this);
            const $labelText = $item.find('span').first();
            const labelText = $labelText.text().toLowerCase();
            const atomicSymbol = $item.attr('data-atomic-symbol');
            
           
            const matches = labelText.includes(searchTerm) || 
                           (atomicSymbol && atomicSymbol.toLowerCase().includes(searchTerm));
            
            if (matches) {
                $item.show();
                hasVisibleResults = true;
               
                highlightSearchTermInLabelNode($item, searchTerm);
            } else {
                $item.hide();
            }
        });

       
        $nestedLabels.each(function() {
            const $item = $(this);
            const originalText = $item.attr('data-original-text') || $item.text();
            if (!$item.attr('data-original-text')) {
                $item.attr('data-original-text', originalText);
            }
            $item.text(originalText);
            
            const labelText = originalText.toLowerCase();
            const matches = labelText.includes(searchTerm);
            
            if (matches) {
                $item.show();
                hasVisibleResults = true;
                highlightSearchTerm($item, searchTerm);
            } else {
                $item.hide();
            }
        });

       
        if (!hasVisibleResults) {
            showNoResultsMessage();
        }
    }

    
    function highlightSearchTermInLabelNode($element, searchTerm) {
        const $labelText = $element.find('span').first();
        const originalText = $labelText.text();
        const regex = new RegExp(`(${searchTerm})`, 'gi');
        const highlightedText = originalText.replace(regex, '<mark style="background-color: #ffeb3b; padding: 1px 2px;">$1</mark>');
        $labelText.html(highlightedText);
    }

    
    function highlightSearchTerm($element, searchTerm) {
        const originalText = $element.text();
        const regex = new RegExp(`(${searchTerm})`, 'gi');
        const highlightedText = originalText.replace(regex, '<mark style="background-color: #ffeb3b; padding: 1px 2px;">$1</mark>');
        $element.html(highlightedText);
    }

    
    function showNoResultsMessage() {
        hideNoResultsMessage();
        const $noResults = $('<div class="no-results-message text-muted text-center py-3">')
            .html('<i class="fa fa-search"></i><br>No labels found<br><small>Try different search terms</small>');
        $('#plain-labels').after($noResults);
    }

    
    function hideNoResultsMessage() {
        $('.no-results-message').remove();
    }

    
    function resetLabelSearch() {
        $('#label-search-input').val('');
        hideNoResultsMessage();
        $('#plain-labels .draggable-label-node, #nested-labels .list-group-item').show();
    }

   
    $(document).ready(function() {
        const $board = $('#board');
        
       
        $board.on('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
            $(this).addClass('drag-over');
            e.originalEvent.dataTransfer.dropEffect = 'copy';
        });

        $board.on('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            $(this).removeClass('drag-over');
        });

       
        $board.on('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            $(this).removeClass('drag-over');
            
            try {
                const data = JSON.parse(e.originalEvent.dataTransfer.getData('text/plain'));
                
                if (data.type === 'label-node') {
                   
                    let x = e.originalEvent.clientX - $(this).offset().left;
                    let y = e.originalEvent.clientY - $(this).offset().top;
                    
                   
                    if (s.sigmaMouse) {
                        x = x - s.sigmaMouse.offsetWidth / 2;
                        y = y - s.sigmaMouse.offsetHeight / 2;
                    }
                    
                   
                    let p = s.camera.cameraPosition(x, y);
                    
                   
                    addLabeledNodeToConstructor(data.atomicSymbol, data.labelId, p.x, p.y);
                }
            } catch (error) {
                console.error('Error handling drop:', error);
            }
        });
    });

    
    function updateNodeCounter() {
        if (window.sigma_constructor && window.sigma_constructor.graph) {
            const nodeCount = window.sigma_constructor.graph.nodes().length;
            $('#node-count').text(nodeCount);
            console.log(`节点计数器已更新: ${nodeCount} 个节点`);
        } else {
            $('#node-count').text('0');
        }
    }

    
    function optimizeEdgeLengthsBeforeScaling(s) {
        
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        const queryNodes = nodes.filter(node => node.isOriginalQuery);
        
        if (nodes.length < 2 || edges.length === 0) {
            console.log('节点或边数量不足，跳过边长度优化');
            return;
        }
        
       
        let queryCentroid = { x: 0, y: 0 };
        const queryConstraints = new Map();
        
        if (queryNodes.length > 0) {
            queryCentroid.x = queryNodes.reduce((sum, node) => sum + node.x, 0) / queryNodes.length;
            queryCentroid.y = queryNodes.reduce((sum, node) => sum + node.y, 0) / queryNodes.length;
            
           
            queryNodes.forEach(node => {
                const relativeX = node.x - queryCentroid.x;
                const relativeY = node.y - queryCentroid.y;
                const distance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);
                const angle = Math.atan2(relativeY, relativeX);
                
                queryConstraints.set(node.id, { distance, angle });
            });
        }
        
       
        const nodeSize = s.nodeSize || RESULT_NODE_SIZE;
        const targetEdgeLength = nodeSize * 4;
        const maxEdgeLength = nodeSize * 6;   
        
        console.log(`目标边长度: ${targetEdgeLength}, 最大边长度: ${maxEdgeLength}`);
        
       
        const edgeLengths = [];
        edges.forEach(edge => {
            const sourceNode = nodes.find(n => n.id === edge.source);
            const targetNode = nodes.find(n => n.id === edge.target);
            
            if (sourceNode && targetNode) {
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                edgeLengths.push({edge, length, sourceNode, targetNode});
            }
        });
        
       
        const longEdges = edgeLengths.filter(e => e.length > maxEdgeLength);
        if (longEdges.length === 0) {
            return;
        }
        
       
        longEdges.forEach(({edge, length, sourceNode, targetNode}) => {
           
            const sourceMoveScale = 1.0;
            const targetMoveScale = 1.0;
            
           
            const dx = targetNode.x - sourceNode.x;
            const dy = targetNode.y - sourceNode.y;
            const currentLength = length;
            const desiredLength = Math.min(targetEdgeLength, currentLength * 0.7);
            
            const scaleFactor = desiredLength / currentLength;
            const centerX = (sourceNode.x + targetNode.x) / 2;
            const centerY = (sourceNode.y + targetNode.y) / 2;
            
           
            const totalMoveScale = sourceMoveScale + targetMoveScale;
            const halfDx = dx * scaleFactor / 2;
            const halfDy = dy * scaleFactor / 2;
            
           
            const sourceRatio = sourceMoveScale / totalMoveScale;
            const targetRatio = targetMoveScale / totalMoveScale;
            
            sourceNode.x = centerX - halfDx * sourceRatio;
            sourceNode.y = centerY - halfDy * sourceRatio;
            targetNode.x = centerX + halfDx * targetRatio;
            targetNode.y = centerY + halfDy * targetRatio;
            
        });
       
        s.refresh();
    }

    
    function applyFreeLayout(s, duration = 2000) {
        console.log('Starting complete free layout algorithm...');
        
        const nodes = s.graph.nodes();
        const edges = s.graph.edges();
        
        if (nodes.length === 0) {
            console.log('No nodes to layout');
            s.refresh();
            return;
        }
        
       
        nodes.forEach(node => {
            delete node.isOriginalQuery;
            delete node.isNewNode;
            delete node.isFixedPosition;
        });
        
        console.log(`Complete free layout: processing ${nodes.length} nodes, ${edges.length} edges`);
        
       
        const totalNodes = nodes.length;
        const currentNodeSize = s.nodeSize || RESULT_NODE_SIZE;
        let baseDistance, repulsionStrength, attractionStrength;
        
       
        const distanceMultiplier = totalNodes > 20 ? 3.2 : totalNodes > 15 ? 3.5 : totalNodes > 12 ? 3.8 : 4.0;
        baseDistance = Math.max(35, currentNodeSize * distanceMultiplier);
        
        if (totalNodes > 20) {
            repulsionStrength = 1800;
            attractionStrength = 0.06;
            console.log(`Super large graph free layout parameters: node=${currentNodeSize}, distance=${baseDistance.toFixed(1)}, repulsion=${repulsionStrength}`);
        } else if (totalNodes > 15) {
            repulsionStrength = 1600;
            attractionStrength = 0.08;
            console.log(`Large graph free layout parameters: node=${currentNodeSize}, distance=${baseDistance.toFixed(1)}, repulsion=${repulsionStrength}`);
        } else if (totalNodes > 12) {
            repulsionStrength = 1400;
            attractionStrength = 0.10;
            console.log(`Medium-large graph free layout parameters: node=${currentNodeSize}, distance=${baseDistance.toFixed(1)}, repulsion=${repulsionStrength}`);
        } else {
            repulsionStrength = 1200;
            attractionStrength = 0.12;
            console.log(`Medium-small graph free layout parameters: node=${currentNodeSize}, distance=${baseDistance.toFixed(1)}, repulsion=${repulsionStrength}`);
        }
        
       
        const adjacencyMap = new Map();
        edges.forEach(edge => {
            if (!adjacencyMap.has(edge.source)) adjacencyMap.set(edge.source, []);
            if (!adjacencyMap.has(edge.target)) adjacencyMap.set(edge.target, []);
            adjacencyMap.get(edge.source).push(edge.target);
            adjacencyMap.get(edge.target).push(edge.source);
        });
        
       
        const layoutParams = {
            k: baseDistance,             
            repulsion: repulsionStrength,
            attraction: attractionStrength,
            damping: 0.88,
            maxDisplacement: 10,
            minDistance: baseDistance * 0.7,
            maxEdgeLength: baseDistance * 2.8,
            repulsionRange: baseDistance * 4
        };
        
       
        const iterations = Math.floor(duration / 15);
        let currentIteration = 0;
        
        console.log(`Starting ${iterations} iterations of free layout...`);
        
        const layoutInterval = setInterval(() => {
           
            nodes.forEach(node => {
                let fx = 0, fy = 0;
                
               
                nodes.forEach(otherNode => {
                    if (node.id === otherNode.id) return;
                    
                    const dx = node.x - otherNode.x;
                    const dy = node.y - otherNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0 && distance < layoutParams.repulsionRange) {
                        const effectiveDistance = Math.max(distance, layoutParams.minDistance * 0.3);
                        let repulsionForce = layoutParams.repulsion / (effectiveDistance * effectiveDistance);
                        
                       
                        if (distance < layoutParams.minDistance) {
                            repulsionForce *= 2.5;
                        }
                        
                        fx += (dx / distance) * repulsionForce;
                        fy += (dy / distance) * repulsionForce;
                    }
                });
                
               
                const neighbors = adjacencyMap.get(node.id) || [];
                neighbors.forEach(neighborId => {
                    const neighbor = nodes.find(n => n.id === neighborId);
                    if (!neighbor) return;
                    
                    const dx = neighbor.x - node.x;
                    const dy = neighbor.y - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        let displacement = distance - layoutParams.k;
                        
                       
                        if (distance > layoutParams.maxEdgeLength) {
                            displacement += (distance - layoutParams.maxEdgeLength) * 0.9;
                        }
                        
                        const attractionForce = layoutParams.attraction * displacement;
                        fx += (dx / distance) * attractionForce;
                        fy += (dy / distance) * attractionForce;
                    }
                });
                
               
                const crossingForce = calculateEdgeCrossingForce(node, nodes, edges, layoutParams.k * 0.25);
                fx += crossingForce.x * 0.7;
                fy += crossingForce.y * 0.7;
                
               
                fx *= layoutParams.damping;
                fy *= layoutParams.damping;
                
                const displacement = Math.sqrt(fx * fx + fy * fy);
                if (displacement > layoutParams.maxDisplacement) {
                    fx = (fx / displacement) * layoutParams.maxDisplacement;
                    fy = (fy / displacement) * layoutParams.maxDisplacement;
                }
                
               
                node.x += fx;
                node.y += fy;
            });
            
           
            enforceMinimumDistanceForFreeLayout(nodes, layoutParams.minDistance);
            
           
            s.refresh();
            
            currentIteration++;
            if (currentIteration >= iterations) {
                clearInterval(layoutInterval);
                console.log('Complete free layout finished');
                
               
                performFinalOverlapResolutionForFreeLayout(s);
                
               
                setTimeout(() => {
                    scaleTofitContainer(s);
                }, 100);
                
                console.log('Free layout optimization completed! Graph is optimized to the best state');
            }
            
           
            layoutParams.repulsion *= 0.988;
            layoutParams.maxDisplacement *= 0.988;
        }, 15);
    }
    
    
    function enforceMinimumDistanceForFreeLayout(nodes, minDistance) {
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                const node1 = nodes[i];
                const node2 = nodes[j];
                
                const dx = node2.x - node1.x;
                const dy = node2.y - node1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const node1Radius = (node1.size || 8) / 2;
                const node2Radius = (node2.size || 8) / 2;
                const requiredDistance = node1Radius + node2Radius + minDistance;
                
                if (distance < requiredDistance && distance > 0) {
                    const separation = requiredDistance - distance;
                    const moveX = (dx / distance) * separation * 0.5;
                    const moveY = (dy / distance) * separation * 0.5;
                    
                   
                    node1.x -= moveX;
                    node1.y -= moveY;
                    node2.x += moveX;
                    node2.y += moveY;
                }
            }
        }
    }
    
    
    function performFinalOverlapResolutionForFreeLayout(s) {
        
        const nodes = s.graph.nodes();
        const totalNodes = nodes.length;
        const currentNodeSize = s.nodeSize || RESULT_NODE_SIZE;
        
       
        const baseMultiplier = totalNodes > 20 ? 2.2 : totalNodes > 15 ? 2.4 : totalNodes > 12 ? 2.6 : 2.8;
        const minSeparation = Math.max(8, currentNodeSize * baseMultiplier);
        const maxIterations = totalNodes > 20 ? 6 : totalNodes > 15 ? 5 : 4;
        
        console.log(`Free layout overlap resolution: node size=${currentNodeSize}, separation=${minSeparation.toFixed(1)}, iterations=${maxIterations}`);
        
        for (let iter = 0; iter < maxIterations; iter++) {
            let hasOverlap = false;
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const node1 = nodes[i];
                    const node2 = nodes[j];
                    
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const node1Radius = (node1.size || 10) / 2;
                    const node2Radius = (node2.size || 10) / 2;
                    const requiredDistance = node1Radius + node2Radius + minSeparation;
                    
                    if (distance < requiredDistance) {
                        hasOverlap = true;
                        
                        if (distance === 0) {
                            const randomAngle = Math.random() * 2 * Math.PI;
                            const randomDistance = requiredDistance + Math.random() * 15;
                            
                            const moveX = Math.cos(randomAngle) * randomDistance * 0.5;
                            const moveY = Math.sin(randomAngle) * randomDistance * 0.5;
                            
                            node1.x -= moveX;
                            node1.y -= moveY;
                            node2.x += moveX;
                            node2.y += moveY;
                        } else {
                            const overlap = requiredDistance - distance;
                            const moveDistance = overlap * 0.9;
                            
                            const moveX = (dx / distance) * moveDistance * 0.5;
                            const moveY = (dy / distance) * moveDistance * 0.5;
                            
                            node1.x -= moveX;
                            node1.y -= moveY;
                            node2.x += moveX;
                            node2.y += moveY;
                        }
                    }
                }
            }
            
            if (!hasOverlap) {
                console.log(`${iter + 1}`);
                break;
            }
            
            s.refresh();
        }
    }

    
    function addLabeledNodeToConstructor(atomicSymbol, labelId, x, y) {
       
        if (addNode(s, x, y, false, atomicSymbol)) {
           
            const addedNode = s.graph.nodes()[s.graph.nodes().length - 1];
            addedNode.originalLabel = String(labelId);
            
           
            s.activeState.dropNodes();
            s.activeState.addNodes(addedNode.id);
            
           
            s.refresh();
            
           
        debouncedSaveQueryGraph();
            
            console.log(`Added labeled node: ${atomicSymbol} at (${x.toFixed(2)}, ${y.toFixed(2)})`);
        } else {
           
            console.log(`Failed to add node at (${x.toFixed(2)}, ${y.toFixed(2)}) - too close to existing node`);
        }
    }
</script>


<script src="js/popper.min.js"></script>
<script src="js/bootstrap.min.js"></script>

<script src="js/sigma.min.js"></script>
<script src="js/plugins/sigma.plugins.activeState.min.js"></script>
<script src="js/plugins/sigma.plugins.dragNodes.min.js"></script>
<script src="js/plugins/sigma.plugins.select.min.js"></script>
<script src="js/plugins/sigma.plugins.lasso.min.js"></script>
<script src="js/plugins/sigma.renderers.halo.min.js"></script>

<script src="js/dagre.js"></script>
<script src="js/plugins/sigma.layouts.dagre.min.js"></script>

<script src="js/plugins/sigma.layouts.forceAtlas2/supervisor.js"></script>
<script src="js/plugins/sigma.layouts.forceAtlas2/worker.js"></script>
<script src="js/plugins/sigma.layouts.forceAtlas2.min.js"></script>

<script src="js/plugins/sigma.plugins.animate.min.js"></script>
<script src="js/plugins/sigma.layouts.fruchtermanReingold.min.js"></script>

<script src="js/plugins/sigma.layouts.noverlap.min.js"></script>

<script src="js/plugins/sigma.layouts.forceLink/supervisor.js"></script>
<script src="js/plugins/sigma.layouts.forceLink/worker.js"></script>
<script src="js/plugins/sigma.layouts.forceLink.min.js"></script>
</body>

</html>